<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 多线程</title>
      <link href="/2025/03/21/java-multithreading/"/>
      <url>/2025/03/21/java-multithreading/</url>
      
        <content type="html"><![CDATA[<h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://liaoxuefeng.com/books/java/threading/index.html">多线程 - Java教程 - 廖雪峰的官方网站</a></p><blockquote><p>多数参考了廖老师的博客 非常好教程</p></blockquote><p><a href="https://segmentfault.com/a/1190000023960592">万字图解Java多线程 - 个人文章 - SegmentFault 思否</a></p><blockquote><p>相对没那么详细，就讲到同步锁和线程池，简洁清晰</p><p>也补充了一些知识，例如线程状态，同步锁，生产者消费者模型……</p></blockquote><h2 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h2><h4 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程&#x2F;线程"></a>进程&#x2F;线程</h4><p>进程和线程的关系： <strong>一个进程可以包含一个或多个线程</strong> ，但至少会有一个线程。</p><p>操作系统调度的 <strong>最小任务单位</strong> 其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p><p>多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程 <strong>开销</strong> 大，尤其是在Windows系统上</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快</li></ul><p>多进程的优点在于：</p><ul><li>多进程 <strong>稳定性</strong> 比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程</li><li>在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃</li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>Java语言内置了多线程支持：一个Java程序实际上是一个 <strong>JVM进程</strong> ，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要 <strong>读写共享数据，并且需要同步</strong> 。</p><p>例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><p><a href="https://liaoxuefeng.com/books/java/threading/new-thread/index.html">创建新线程 - Java教程 - 廖雪峰的官方网站</a></p><p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令新线程能执行指定的代码，有以下几种方法：</p><p><strong>方法一</strong> ：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Overread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p><p><strong>方法二</strong> ：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用Java 8引入的lambda语法进一步简写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，直接调用 <code>run()</code> 方法，并不能实现多线程，当前线程也不会改变，而只是执行 <code>run()</code> 方法</p><blockquote><p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p></blockquote><hr><p>使用线程和直接在 <code>main()</code> 方法中执行的 <strong>区别</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 中命令执行顺序：</p><ul><li><p>打印 <code>main start...</code> </p></li><li><p>创建 <code>Thread</code> 对象</p></li><li><p><code>start</code> 启动新线程</p></li><li><blockquote><p>当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p></blockquote></li><li><p>打印 <code>main end...</code></p></li></ul><p>但是，在 <code>t</code> 线程开始运行后， <code>main</code> 和 <code>t</code> 就 <strong>同时运行</strong> 了，此时程序本身无法确定线程的调度顺序</p><p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，参数的单位是毫秒， <code>sleep()</code> 强迫当前线程 <strong>暂停</strong> 一段时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setPriority(<span class="type">int</span> n) <span class="comment">//默认为5</span></span><br></pre></td></tr></table></figure><p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们 <strong>决不能通过设置优先级来确保高优先级的线程一定会先执行</strong> 。cpu比较忙时，优先级高的线程获取更多的时间片，cpu比较闲时，优先级设置基本没用</p><p> <code>yield()</code> 方法会让运行中的线程切换到就绪状态，重新争抢cpu的时间片，争抢时是否获取到时间片看cpu的分配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">       log.info(<span class="string">&quot;---- 1&gt;&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        log.info(<span class="string">&quot;            ---- 2&gt;&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 运行结果</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129504</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129505</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129506</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129507</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129508</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129509</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129510</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129511</span><br><span class="line">11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129512</span><br><span class="line">11:49:15.798 [t2] INFO thread.TestYield -             ---- 2&gt;293</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129513</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129514</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129515</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129516</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129517</span><br><span class="line">11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129518</span><br></pre></td></tr></table></figure><p>如上述结果所示，t2线程每次执行时进行了yield()，线程1执行的机会明显比线程2要多。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>Java用<code>Thread</code>对象表示一个线程，通过调用<code>start()</code>启动一个新线程</li><li>一个线程对象只能调用一次<code>start()</code>方法</li><li>线程的执行代码写在<code>run()</code>方法中</li><li>线程调度由操作系统决定，程序本身无法决定调度顺序</li><li><code>Thread.sleep()</code>可以把当前线程暂停一段时间</li></ul><hr><h3 id="线程的阻塞"><a href="#线程的阻塞" class="headerlink" title="线程的阻塞"></a>线程的阻塞</h3><p>使得线程阻塞的方式有下面几种：</p><ul><li>BIO阻塞，即使用了阻塞式的io流</li><li>sleep(long time) 让线程休眠进入阻塞状态</li><li>a.join() 调用该方法的线程进入阻塞，等待a线程执行完恢复运行</li><li>sychronized或ReentrantLock 造成线程未获得锁进入阻塞状态</li><li>获得锁之后调用wait()方法 也会让线程进入阻塞状态</li><li>LockSupport.park() 让线程进入阻塞状态</li></ul><h4 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a><code>Thread.sleep()</code></h4><p> 使线程休眠，会将运行中的线程进入阻塞状态。当休眠时间结束后，重新争抢cpu的时间片继续运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法的定义 native方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 休眠2秒</span></span><br><span class="line">   <span class="comment">// 该方法会抛出 InterruptedException异常 即休眠过程中可被中断，被中断后抛出异常</span></span><br><span class="line">   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException异常 e) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 使用TimeUnit的api可替代 Thread.sleep </span></span><br><span class="line">   TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a><code>Thread.join()</code></h4><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);<span class="comment">//java8 lambda方式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start(); <span class="comment">// 启动t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 此处main线程会等待t结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束， <strong>然后才继续往下执行自身线程</strong> 。所以，上述代码打印顺序可以肯定是<code>main</code>线程先打印<code>start</code>，<code>t</code>线程再打印<code>hello</code>，<code>main</code>线程最后再打印<code>end</code>。</p><p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>线程阻塞的常见方式</strong>：BIO阻塞、<code>sleep()</code>、<code>join()</code>、未获取锁（<code>synchronized</code>&#x2F;<code>ReentrantLock</code>）、<code>wait()</code>、<code>LockSupport.park()</code>。</li><li><code>sleep()</code> ：让线程休眠指定时间，可被中断，推荐用<code>TimeUnit</code>增强可读性。</li><li><code>join()</code> ：让当前线程等待目标线程执行完毕，常用于控制线程执行顺序。</li><li><strong>阻塞与恢复</strong>：线程进入阻塞后，需等待特定条件（如时间结束、锁释放、目标线程完成）才能恢复运行。</li></ul><hr><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p><a href="https://liaoxuefeng.com/books/java/threading/interrupt/index.html">中断线程 - Java教程 - 廖雪峰的官方网站</a></p><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>例如，从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><h4 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread.interrupt"></a><code>Thread.interrupt</code></h4><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态， <strong>如果是，就立刻结束运行</strong> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法 <strong>仅仅向<code>t</code>线程发出了“中断请求”</strong> ，至于<code>t</code>线程 <strong>是否能立刻响应，要看具体代码</strong> 。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p><p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>， <strong><code>join()</code>方法会立刻抛出<code>InterruptedException</code></strong> ，因此，目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断</li><li>此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code></li><li>在<code>t</code>线程中捕获了<code>InterruptedException</code>，准备结束该线程</li><li><code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断</li></ul><h4 id="running标志位"><a href="#running标志位" class="headerlink" title="running标志位"></a><code>running</code>标志位</h4><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个 <strong>线程间共享的变量</strong> 。线程间共享变量需要使用<code>volatile</code>关键字标记，确保 <strong>每个线程都能读取到更新后的变量值</strong> 。</p><h4 id="volatile-的用处"><a href="#volatile-的用处" class="headerlink" title="volatile 的用处"></a><code>volatile</code> 的用处</h4><p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是， <strong>这个时间是不确定的</strong> ！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这图画得真有水平罢 </span></span><br><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">           Main Memory</span><br><span class="line">│                               │</span><br><span class="line">   ┌───────┐┌───────┐┌───────┐</span><br><span class="line">│  │ <span class="keyword">var</span> A ││ <span class="keyword">var</span> B ││ <span class="keyword">var</span> C │  │</span><br><span class="line">   └───────┘└───────┘└───────┘</span><br><span class="line">│     │ ▲               │ ▲     │</span><br><span class="line"> ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─</span><br><span class="line">      │ │               │ │</span><br><span class="line">┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐</span><br><span class="line">      ▼ │               ▼ │</span><br><span class="line">│  ┌───────┐  │   │  ┌───────┐  │</span><br><span class="line">   │ <span class="keyword">var</span> A │         │ <span class="keyword">var</span> C │</span><br><span class="line">│  └───────┘  │   │  └───────┘  │</span><br><span class="line">   Thread <span class="number">1</span>          Thread <span class="number">2</span></span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。</p><p>例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在JVM把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了 <strong>多线程之间共享的变量不一致</strong> 。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程 <strong>修改了某个共享变量的值，其他线程能够立刻看到修改后的值</strong> 。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>对目标线程调用<code>interrupt()</code>方法可以请求中断一个线程，目标线程通过检测<code>isInterrupted()</code>标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到<code>InterruptedException</code>；</p><p>目标线程检测到<code>isInterrupted()</code>为<code>true</code>或者捕获了<code>InterruptedException</code>都应该立刻结束自身线程；</p><p>通过标志位判断需要正确使用<code>volatile</code>关键字；</p><p><code>volatile</code>关键字解决了共享变量在线程间的可见性问题。</p><hr><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><a href="https://segmentfault.com/a/1190000023960592#item-2">万字图解Java多线程 - 个人文章 - SegmentFault 思否</a></p><p><a href="https://liaoxuefeng.com/books/java/threading/state/index.html">线程的状态 - Java教程 - 廖雪峰的官方网站</a></p><h4 id="系统-五种状态"><a href="#系统-五种状态" class="headerlink" title="系统 - 五种状态"></a>系统 - 五种状态</h4><p>线程的状态可从 操作系统层面分为五种状态</p><img src="/2025/03/21/java-multithreading/thread-status-1.png" class=""><ol><li>初始状态：创建线程对象时的状态</li><li>可运行状态(就绪状态)：调用 <code>start()</code> 方法后进入就绪状态，也就是准备好被cpu调度执行</li><li>运行状态：线程获取到cpu的时间片， 执行 <code>run()</code> 方法的逻辑</li><li>阻塞状态: 线程被阻塞，放弃cpu的时间片，等待解除阻塞重新回到就绪状态争抢时间片</li><li>终止状态: 线程执行完成或抛出异常后的状态</li></ol><h4 id="Java-六种状态"><a href="#Java-六种状态" class="headerlink" title="Java - 六种状态"></a>Java - 六种状态</h4><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><img src="/2025/03/21/java-multithreading/thread-status-2.png" class=""><ol><li>NEW 线程对象被创建</li><li>Runnable 线程调用了 <code>start()</code> 方法后进入该状态，该状态包含了三种情况<ol><li>就绪状态 :等待cpu分配时间片</li><li>运行状态:进入Runnable方法执行任务</li><li>阻塞状态:BIO 执行阻塞式io流时的状态</li></ol></li><li>Blocked 没获取到锁时的阻塞状态(同步锁章节会细说)</li><li>WAITING 调用 <code>wait()</code>  <code>join()</code> 等方法后的状态</li><li>TIMED_WAITING 调用 <code>sleep(time)</code>  <code>wait(time)</code>  <code>join(time)</code> 等方法后的状态</li><li>TERMINATED 线程执行完成或抛出异常后的状态</li></ol><img src="/2025/03/21/java-multithreading/thread-status-3.png" class=""><p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><h4 id="Thread类中的核心方法"><a href="#Thread类中的核心方法" class="headerlink" title="Thread类中的核心方法"></a>Thread类中的核心方法</h4><table><thead><tr><th>方法名称</th><th>是否static</th><th>方法说明</th></tr></thead><tbody><tr><td>start()</td><td>否</td><td>让线程启动，进入就绪状态,等待cpu分配时间片</td></tr><tr><td>run()</td><td>否</td><td>重写Runnable接口的方法,线程获取到cpu时间片时执行的具体逻辑</td></tr><tr><td>yield()</td><td>是</td><td>线程的礼让，使得获取到cpu时间片的线程进入就绪状态，重新争抢时间片</td></tr><tr><td>sleep(time)</td><td>是</td><td>线程休眠固定时间，进入阻塞状态，休眠时间完成后重新争抢时间片,休眠可被打断</td></tr><tr><td>join()&#x2F;join(time)</td><td>否</td><td>调用线程对象的join方法，调用者线程进入阻塞,等待线程对象执行完或者到达指定时间才恢复，重新争抢时间片</td></tr><tr><td>isInterrupted()</td><td>否</td><td>获取线程的打断标记，true:被打断，false：没有被打断。调用后不会修改打断标记</td></tr><tr><td>interrupt()</td><td>否</td><td>打断线程，抛出InterruptedException异常的方法均可被打断，但是打断后不会修改打断标记，正常执行的线程被打断后会修改打断标记</td></tr><tr><td>interrupted()</td><td>否</td><td>获取线程的打断标记。调用后会清空打断标记</td></tr><tr><td>stop()</td><td>否</td><td>停止线程运行 不推荐</td></tr><tr><td>suspend()</td><td>否</td><td>挂起线程 不推荐</td></tr><tr><td>resume()</td><td>否</td><td>恢复线程运行 不推荐</td></tr><tr><td>currentThread()</td><td>是</td><td>获取当前线程</td></tr></tbody></table><p>Object中与线程相关方法</p><table><thead><tr><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>wait()&#x2F;wait(long timeout)</td><td>获取到锁的线程进入阻塞状态</td></tr><tr><td>notify()</td><td>随机唤醒被wait()的一个线程</td></tr><tr><td>notifyAll();</td><td>唤醒被wait()的所有线程，重新争抢时间片</td></tr></tbody></table><hr><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><a href="https://liaoxuefeng.com/books/java/threading/daemon/index.html">守护线程 - Java教程 - 廖雪峰的官方网站</a></p><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p><p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p><p>答案是使用守护线程（Daemon Thread）。</p><p>守护线程是指为其他线程服务的线程。在JVM中， <strong>所有非守护线程都执行完毕后</strong> ，无论有没有守护线程，虚拟机都会自动退出。</p><p>因此，JVM退出时，不必关心守护线程是否已结束。</p><p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前， <strong>调用<code>setDaemon(true)</code>把该线程标记为守护线程</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意： <strong>守护线程不能持有任何需要关闭的资源</strong> ，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>守护线程是为其他线程服务的线程；</p><p>所有非守护线程都执行完毕后，虚拟机退出，守护线程随之结束；</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><hr><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><a href="https://liaoxuefeng.com/books/java/threading/synchronize/index.html">线程同步 - Java教程 - 廖雪峰的官方网站</a></p><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count += <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123; Counter.count -= <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确， <strong>必须保证是原子操作</strong> 。原子操作是指不能被中断的一个或一系列操作。</p><p>例如，对于语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>看上去是一行语句，实际上对应了3条指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │ILOAD (<span class="number">100</span>)  │</span><br><span class="line">    │             │ILOAD (<span class="number">100</span>)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (<span class="number">101</span>)</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (<span class="number">101</span>) │</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure><p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时， <strong>必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待</strong> ：</p><h4 id="synchronized-同步锁"><a href="#synchronized-同步锁" class="headerlink" title="synchronized 同步锁"></a><code>synchronized 同步锁</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">┌───────┐     ┌───────┐</span><br><span class="line">│Thread1│     │Thread2│</span><br><span class="line">└───┬───┘     └───┬───┘</span><br><span class="line">    │             │</span><br><span class="line">    │-- lock --   │</span><br><span class="line">    │ILOAD (<span class="number">100</span>)  │</span><br><span class="line">    │IADD         │</span><br><span class="line">    │ISTORE (<span class="number">101</span>) │</span><br><span class="line">    │-- unlock -- │</span><br><span class="line">    │             │-- lock --</span><br><span class="line">    │             │ILOAD (<span class="number">101</span>)</span><br><span class="line">    │             │IADD</span><br><span class="line">    │             │ISTORE (<span class="number">102</span>)</span><br><span class="line">    │             │-- unlock --</span><br><span class="line">    ▼             ▼</span><br></pre></td></tr></table></figure><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区(Critical Section)，任何时候临界区最多只有一个线程能执行。</p><p>可见， <strong>保证一段代码的原子性就是通过加锁和解锁实现的</strong> 。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>保证了代码块在 <strong>任意时刻最多只有一个线程能执行</strong> 。我们把上面的代码用<code>synchronized</code>改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Counter.lock) &#123; <span class="comment">// 获取锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><p>它表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p><p>我们来概括一下如何使用<code>synchronized</code>：</p><ol><li>找出修改共享变量的线程代码块；</li><li>选择一个共享实例作为锁；</li><li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li></ol><p>在使用<code>synchronized</code>的时候， <strong>不必担心抛出异常</strong> 。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">    &#125; <span class="comment">// 无论有无异常，都会在此释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，多个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取， <strong>但两个不同的锁在同一时刻可以被两个线程分别获取</strong> 。</p><p>因此，使用<code>synchronized</code>的时候， <strong>获取到的是哪个锁非常重要</strong> 。锁对象如果不对，代码逻辑就不对。</p><p>下面是应用了两个不同的锁来提升效率的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>[] &#123; <span class="keyword">new</span> <span class="title class_">AddStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">DecStudentThread</span>(), <span class="keyword">new</span> <span class="title class_">AddTeacherThread</span>(), <span class="keyword">new</span> <span class="title class_">DecTeacherThread</span>() &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Counter.studentCount);</span><br><span class="line">        System.out.println(Counter.teacherCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockStudent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">studentCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">teacherCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">                Counter.studentCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecStudentThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lockStudent) &#123;</span><br><span class="line">                Counter.studentCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">                Counter.teacherCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecTeacherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lockTeacher) &#123;</span><br><span class="line">                Counter.teacherCount -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不需要-synchronized-的操作"><a href="#不需要-synchronized-的操作" class="headerlink" title="不需要 synchronized 的操作"></a>不需要 <code>synchronized</code> 的操作</h4><p>JVM规范定义了几种原子操作：</p><ul><li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li><li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li></ul><p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不需要同步。</p><p>对引用也是类似。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <strong>赋值语句</strong> 并不需要同步。</p><p>但是，如果是 <strong>多行赋值语句，就必须保证是同步操作</strong> ，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的读写，即( set(), get() )需要同步，在读的时候若是不同步，会造成程序的逻辑错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        copy[<span class="number">0</span>] = x;</span><br><span class="line">        copy[<span class="number">1</span>] = y;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>假定当前坐标是<code>(100, 200)</code>，那么当设置新坐标为<code>(110, 220)</code>时，上述未同步的多线程读到的值可能有：</p><ul><li>(100, 200)：x，y更新前；</li><li>(110, 200)：x更新后，y更新前；</li><li>(110, 220)：x，y更新后。</li></ul><p>如果读取到<code>(110, 200)</code>，即读到了更新后的x，更新前的y，无法保证读取的多个变量状态保持一致。</p><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] ps;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;;</span><br><span class="line">        <span class="built_in">this</span>.ps = ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不再需要写同步，因为<code>this.ps = ps</code>是引用赋值的原子操作。而语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p><p>不过要注意，读方法在复制<code>int[]</code>数组的过程中仍然需要同步。</p><h4 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h4><p>不可变对象是指<strong>创建后状态不能被修改的对象</strong>。在 Java 中，典型的不可变对象包括：</p><ul><li><code>String</code></li><li><code>List.of()</code> 创建的不可变集合（Java 9+）</li><li>基本类型的包装类（如 <code>Integer</code>, <code>Long</code> 等）</li></ul><p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p><p>分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。对于下面这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ns = List.of(names);</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">    StatusRecord <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StatusRecord</span>(<span class="built_in">this</span>.names, <span class="built_in">this</span>.x, <span class="built_in">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有A、B两个线程，同时执行是指：</p><ul><li>可能同时执行set()；</li><li>可能同时执行get()；</li><li>可能A执行set()，同时B执行get()。</li></ul><p>类的成员变量<code>names</code>、<code>x</code>、<code>y</code>显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量<code>step</code>仅在<code>set()</code>方法内部使用，因此每个线程同时执行set时都有一份独立的step存储在线程的栈上，互不影响，</p><p>局部变量<code>ns</code>虽然每个线程也各有一份，但后续赋值<code> this.names = ns</code> 对其他线程就变成可见了。对<code>set()</code>方法同步时，如果要最小化<code>synchronized</code>代码块，可以改写如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String[] names, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 局部变量其他线程不可见:</span></span><br><span class="line">    List&lt;String&gt; ns = List.of(names);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> n * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = ns;</span><br><span class="line">        <span class="built_in">this</span>.x += step;</span><br><span class="line">        <span class="built_in">this</span>.y += step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p><table><thead><tr><th align="left">场景</th><th align="left">是否需要同步</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left">不可变对象（如 <code>List.of()</code>）</td><td align="left">否</td><td align="left">对象不可变，多线程只能读取，无竞态条件。</td></tr><tr><td align="left">局部变量（如 <code>step</code>）</td><td align="left">否</td><td align="left">线程私有，栈封闭。</td></tr><tr><td align="left">成员变量赋值（如 <code>this.names</code>）</td><td align="left">是</td><td align="left">引用可能被多线程同时修改，需同步或 <code>volatile</code>。</td></tr><tr><td align="left">复合操作（如 <code>x += step</code>）</td><td align="left">是</td><td align="left">非原子操作（读取-修改-写入），需同步。</td></tr></tbody></table><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>多线程同时读写共享变量时，可能会造成逻辑错误，因此需要通过<code>synchronized</code>同步；</p><p>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</p><p>注意加锁对象必须是同一个实例；</p><p>对JVM定义的单个原子操作不需要同步。</p><hr><h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p><p>还有一些 <strong>不变类</strong> ，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些 <strong>只提供静态方法，没有成员变量的类</strong> ，也是线程安全的。</p><p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是 <strong>非线程安全的类</strong> ，我们不能在多线程中修改它们。但是，如果所有线程都 <strong>只读取，不写入</strong> ，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p><blockquote><p>没有特殊说明时，一个类 <strong>默认是非线程安全的</strong> 。</p></blockquote><p>例如下面的Counter类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，**<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行**</p><h4 id="synchronized-修饰"><a href="#synchronized-修饰" class="headerlink" title="synchronized 修饰"></a><code>synchronized</code> 修饰</h4><p>我们再观察<code>Counter</code>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>因此， <strong>用<code>synchronized</code>修饰的方法就是同步方法</strong> ，它表示整个方法都必须用<code>this</code>实例加锁。</p><p>对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的<code>Class</code>实例，因此， <strong>对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例</strong> 。上述<code>synchronized static</code>方法实际上相当于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code>；</p><p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p><p>一个类没有特殊说明，默认不是thread-safe；</p><p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p><hr><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>Java的线程锁是可重入的锁。</p><p>什么是可重入的锁？我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ol><li>调用<code>add(-1)</code>：<ul><li>获取<code>this</code>锁：计数器&#x3D;1，持有线程&#x3D;当前线程</li></ul></li><li>进入<code>add</code>方法后调用<code>dec(1)</code>：<ul><li>再次获取<code>this</code>锁：发现当前线程已持有，计数器增加到2</li></ul></li><li>退出<code>dec</code>方法：<ul><li>计数器减到1</li></ul></li><li>退出<code>add</code>方法：<ul><li>计数器减到0，真正释放锁</li></ul></li></ol><p>观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁，现在问题来了：</p><p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p><p>答案是肯定的。 <strong>JVM允许同一个线程重复获取同一个锁</strong> ，这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong>。</p><p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p><h4 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h4><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p><ul><li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li><li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li></ul><p>随后：</p><ul><li>线程1：准备获得<code>lockB</code>，失败，等待中；</li><li>线程2：准备获得<code>lockA</code>，失败，等待中。</li></ul><p> <strong>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</strong> </p><p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p><p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p><p>那么我们应该如何避免死锁呢？答案是： <strong>线程获取锁的顺序要一致</strong> 。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>Java的<code>synchronized</code>锁是可重入锁；</p><p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p><p>避免死锁的方法是多线程获取锁的顺序要一致。</p><hr><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>在Java程序中，<code>synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code>synchronized</code>加锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>synchronized</code>并没有解决多线程协调的问题。</p><p>仍然以上面的<code>TaskQueue</code>为例，我们再编写一个<code>getTask()</code>方法取出队列的第一个任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p><p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p><p>因此，执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用CPU资源。</p><p>如果深入思考一下，我们想要的执行效果是：</p><ul><li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li><li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li></ul><p> <strong>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</strong> </p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a><code>wait()</code></h4><p>对于上述<code>TaskQueue</code>，我们先改造<code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p><p>这里的关键是：<code>wait()</code>方法必须在 <strong>当前获取的锁对象</strong> 上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p><p>调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻， <strong>线程从等待状态被其他线程唤醒后</strong> ，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p><p>有些仔细的童鞋会指出：即使线程在<code>getTask()</code>内部等待，其他线程如果拿不到<code>this</code>锁，照样无法执行<code>addTask()</code>，肿么办？</p><p>这个问题的关键就在于<code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法， <strong>因为<code>wait()</code>方法调用时，会释放线程获得的锁</strong> ，<code>wait()</code>方法返回时，线程又会重新试图获得锁。</p><p>因此，只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 释放this锁:</span></span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">        <span class="comment">// 重新获取this锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程在<code>this.wait()</code>等待时，它就会释放<code>this</code>锁，从而使得其他线程能够在<code>addTask()</code>方法获得<code>this</code>锁。</p><h4 id="notify"><a href="#notify" class="headerlink" title="notify()"></a><code>notify()</code></h4><p>现在我们面临第二个问题：如何让等待的线程被 <strong>重新唤醒</strong> ，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    <span class="built_in">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p><p>我们来看一个完整的例子(这也是一个生产者消费者模型)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会 <strong>唤醒其中一个</strong> （具体哪个依赖操作系统，有一定的 <strong>随机性</strong>）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将 <strong>一次性全部唤醒</strong> 。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p><p>但是，注意到<code>wait()</code>方法返回时需要 <em>重新</em> 获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下两个将继续等待。</p><p>再注意到我们在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取<code>this</code>锁。多个线程被唤醒后，只有一个线程能获取<code>this</code>锁，此刻，该线程执行<code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取<code>this</code>锁后执行<code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在<code>while</code>循环中<code>wait()</code>，并且每次被唤醒后拿到<code>this</code>锁就必须再次判断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p><code>wait</code>和<code>notify</code>用于多线程协调运行：</p><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><hr><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p><a href="https://www.bilibili.com/video/BV1tX4y1S7Hz/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=c8beb52bf015e61e5378008c684545a4">Java生产者消费者模式的实现和解析_哔哩哔哩_bilibili</a></p><p>下面是从B站找来的简单的生产者消费者模型的示例，并不如上面线程通信中的示例以及下面的消息队列模型示例，这三个示例我想就能拿下该模型罢</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交替执行两个线程</span></span><br><span class="line"><span class="comment">     * 一个输出“1,2,3,...”</span></span><br><span class="line"><span class="comment">     * 一个输出“a,b,c,...”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">26</span>;i++)&#123;</span><br><span class="line">                    factory.product(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;i &lt;= <span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">                    factory.consume((<span class="type">char</span>) i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0: 生产者正在生成，消费者正在等待，生产者结束生产后告知消费者进行消费</span></span><br><span class="line"><span class="comment">     * 1: 消费者正在消费，生产者正在等待，消费者结束消费后高职生产者进行生产</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//状态值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">product</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(n);</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">        <span class="built_in">this</span>.sign = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sign == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(c);</span><br><span class="line">        <span class="built_in">this</span>.notify();</span><br><span class="line">        <span class="built_in">this</span>.sign = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程的运行有一定随机性，往往用户无法决定，但是生产者消费者模型，能实现两个线程的“交替”运行</p><p>注释里的内容不再概述，我们来分析一下：</p><p>假设线程 <code>t1</code> 先被调用，由于 <code>sign = 0</code> ，所以打印字符 <code>1</code> ， <code>sign</code> 变为1。下面有两种可能，调用线程 <code>t1</code> 或 <code>t2</code> </p><p>调用 <code>t1</code> :</p><ul><li><code>sign = 1</code> 进入 <code>try/catch</code> </li><li>同步锁的对象 <code>this。wait()</code> 也就是进入 <strong>“等待”</strong> 状态</li><li><code>wait()</code> 会 <strong>释放锁</strong> ，线程 <code>t2</code> 执行，运行 <code>consume()</code></li><li><code>notfiy()</code>  <strong>唤醒</strong>  <code>this</code> 中等待的线程 <code>t1</code> </li><li><code>sign</code> 被赋值0，周而复始</li></ul><p>调用 <code>t2</code> :</p><ul><li>线程 <code>t2</code> 执行，运行 <code>consume()</code> </li><li><code>notify</code> 不唤醒任一线程(因为无线程处于等待状态)</li><li><code>sign</code> 被赋值0，周而复始</li></ul><h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p>下面是较复杂(贴切实际)的一种，思想和上面简单的例子差不多的</p><blockquote><p> 关于下面示例中 <code>lambda</code> 表达式创建线程的方式，需要补充几点：</p><ul><li><code>new Thread()</code> - 创建新线程</li><li><code>() -&gt; &#123;...&#125;</code> - Lambda表达式定义线程任务</li><li><code>&quot;生产者&quot; + i</code> - 线程命名</li><li><code>.start()</code> - 启动线程</li></ul></blockquote><p>这里通过循环来创建线程，所以用循环的参数为其命名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三个生产者向队列里存值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;值&quot;</span> + id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个消费者不停的从队列里取值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                queue.take();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息队列被生产者和消费者持有</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;队列已满，生产者等待&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.info(<span class="string">&quot;生产消息:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            <span class="comment">// 生产后通知消费者</span></span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;队列已空，消费者等待&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            <span class="comment">//从队列头部取出消息</span></span><br><span class="line">            log.info(<span class="string">&quot;消费消息:&#123;&#125;&quot;</span>, message);</span><br><span class="line">            <span class="comment">// 消费后通知生产者</span></span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 消息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数:</p><ul><li>创建了一个容量为2的消息队列<code>MessageQueue</code></li><li>启动3个生产者线程，每个生产者向队列中放入一条消息</li><li>主线程休眠1秒，让生产者有足够时间开始工作</li><li>启动一个消费者线程，不断从队列中取出消息</li></ul><p>生产者:</p><ul><li>使用<code>synchronized</code>块获取<code>list</code>对象的锁</li><li>检查队列是否已满（<code>while</code>循环防止虚假唤醒）</li><li>如果队列已满，调用<code>wait()</code>释放锁并等待</li><li>当队列有空闲时，添加消息到队列尾部</li><li>调用<code>notifyAll()</code>唤醒可能正在等待的消费者线程</li></ul><p>消费者:</p><ul><li>使用<code>synchronized</code>块获取<code>list</code>对象的锁</li><li>检查队列是否为空（<code>while</code>循环防止虚假唤醒）</li><li>如果队列为空，调用<code>wait()</code>释放锁并等待</li><li>当队列有消息时，从队列头部取出消息</li><li>调用<code>notifyAll()</code>唤醒可能正在等待的生产者线程</li><li>返回取出的消息</li></ul><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ol><li><strong>同步机制</strong>：使用<code>synchronized</code>保证对队列操作的原子性</li><li><strong>等待&#x2F;通知机制</strong>：使用<code>wait()</code>和<code>notifyAll()</code>实现线程间通信</li><li><strong>循环检查条件</strong>：使用<code>while</code>而非<code>if</code>检查条件，防止虚假唤醒</li><li><strong>容量限制</strong>：控制队列大小，防止内存耗尽</li></ol><hr><h3 id="可重入锁-1"><a href="#可重入锁-1" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>从Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>我们知道Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁，我们来看一下传统的<code>synchronized</code>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>ReentrantLock</code>替代，可以把代码改造为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p><p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p><p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p><p>下面来介绍一下它的各种方法，以及一个较复杂的案例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认非公平锁，参数传true 表示未公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line">lock()</span><br><span class="line"><span class="comment">// 释放锁 应放在finally块中 必须执行到</span></span><br><span class="line">unlock()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁时可被打断,阻塞中的线程可被打断</span></span><br><span class="line">    LOCK.lockInterruptibly();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试获取锁 获取不到就返回false</span></span><br><span class="line">LOCK.tryLock()</span><br><span class="line"><span class="comment">// 支持超时时间 一段时间没获取到就返回false</span></span><br><span class="line">tryLock(<span class="type">long</span> timeout, TimeUnit unit)</span><br><span class="line"><span class="comment">// 指定条件变量 休息室 一个锁可以创建多个休息室</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">waitSet</span> <span class="operator">=</span> ROOM.newCondition();</span><br><span class="line"><span class="comment">// 释放锁  进入waitSet等待 释放后其他线程可以抢锁</span></span><br><span class="line">yanWaitSet.await()</span><br><span class="line"><span class="comment">// 唤醒具体休息室的线程 唤醒后 重写竞争锁</span></span><br><span class="line">yanWaitSet.signal()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 构建三个条件变量</span></span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="comment">// 开启三个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先唤醒a</span></span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> print   输出的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current 当前条件变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next    下一个条件变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String print, Condition current, Condition next)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取锁之后等待</span></span><br><span class="line">                    current.await();</span><br><span class="line">                    System.out.print(print);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在Linux(CentOS)系统上部署Minecraft服务器</title>
      <link href="/2025/03/19/Minecraft-server/"/>
      <url>/2025/03/19/Minecraft-server/</url>
      
        <content type="html"><![CDATA[<p>笔者近日配置好了物理服务器，便想利用起来建一个我的世界服务器，经熬夜研究后成功，将本攻略分享出来，希望能帮到大家，尤其是没有公网环境的Linux用户(像我一样)</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://docs.redhat.com/zh-cn/documentation/red_hat_build_of_openjdk/21/html-single/installing_and_using_red_hat_build_of_openjdk_21_on_rhel/index#installing-jre-on-rhel-using-yum_openjdk">在 RHEL 上安装并使用红帽构建的 OpenJDK 21 | Red Hat Product Documentation</a></p><p><a href="https://doc.natfrp.com/launcher/usage.html">SakuraFrp 启动器安装 &#x2F; 使用指南 | SakuraFrp 帮助文档</a></p><p><a href="https://docs.docker.com/engine/install/centos/">CentOS | Docker Docs</a></p><p><a href="https://www.bilibili.com/video/BV1iv4y1P7wJ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=c8beb52bf015e61e5378008c684545a4">Linux终端开服教程★无面板★Minecraft_哔哩哔哩_bilibili</a></p><ul><li>来自B站的UP主<code>翱翔大使</code>，是全篇的主要思路来源</li></ul><h2 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h2><p>运行我的世界需要，须对应版本的Java环境，笔者这里安装的是OpenJDK21</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install java-21-openjdk</span><br><span class="line">java -version //验证是否成功安装</span><br></pre></td></tr></table></figure><p>如果服务器有多个Java版本，可以用<code>alternatives</code>进行版本切换</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure><p>如图，我们输入<code>2</code>并回车，就切换到了需要的版本</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_191616.png" class="" title="Java"><h2 id="游戏部署"><a href="#游戏部署" class="headerlink" title="游戏部署"></a>游戏部署</h2><p>首先在下面这个网址下载Minecraft的服务器端，这里我下的是支持Fabric的Banner(1.20.1)</p><p>[MohistMC](<a href="https://www.mohistmc.com/">MohistMC - 主页</a>)</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_185204.png" class=""><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_185231.png" class=""><p>下载完成后是个类似<code>banner-1.20.1-800-server.jar</code>的文件，接下来打开SSH软件，在服务器上操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/username //切换到个人文件夹或者想安装的位置</span><br><span class="line"><span class="built_in">mkdir</span> Minecraft //创建存放游戏的文件夹</span><br><span class="line"><span class="built_in">cd</span> Minecraft</span><br></pre></td></tr></table></figure><p>我们用SSH软件中的SFTP功能(或其他文件传输功能)，将刚才的游戏文件<code>banner-1.20.1-800-server.jar</code>拷贝到新建的文件夹<code>/home/username/Mineraft</code>中  </p><p>接着我们来写一个服务器的启动脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano start.sh</span><br></pre></td></tr></table></figure><p>其中内容如下填写，但注意各参数的作用</p><ul><li><code>-Xmx</code>是最大分配内存，<code>-Xms</code>是最小分配内存，笔者有32GB内存，为游戏分配了6G(其实可以多分点)</li><li><code>banner-1.20.1-800-server.jar</code>是刚才下载的游戏文件名</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Xmx6144M -Xms6144m -jar banner-1.20.1-800-server.jar</span><br><span class="line"><span class="built_in">stty</span> <span class="built_in">echo</span></span><br></pre></td></tr></table></figure><p>按<code>Ctrl + O</code>写入，<code>Enter</code>确认写入，<code>Ctrl + X</code>退出</p><p>接着为<code>start.sh</code>赋权，避免无权限访问的情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 start.sh</span><br></pre></td></tr></table></figure><p>然后安装<code>screen</code>，简单来说，<code>screen</code>是帮用户创建独立会话，并可以随时恢复的工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><p>  <code>screen</code>有如下几个常用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S [name] //新建名为<span class="string">&quot;name&quot;</span>的screen</span><br><span class="line">screen -<span class="built_in">ls</span> //列出所有运行中的screen的名称和端口</span><br><span class="line">screen -r [port] //返回端口号为port的screen</span><br></pre></td></tr></table></figure><p>接着，新建一个<code>screen</code>运行脚本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S Minecraft</span><br></pre></td></tr></table></figure><p>在新出现的会话中，运行<code>start.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>然后一路顺畅，笔者在这里没有遇到报错，最后来到<code>...EULA...</code>让我们同意EULA协议，输入<code>true</code>后回车，等待一下，游戏服务器就在<code>25565</code>端口上成功运行了</p><p>若想离开Minecraft的这个<code>screen</code>按下<code>Ctrl+A+D</code>即可</p><p>关于游戏规则的更改(比如”是否允许非正版玩家加入“)，需要修改<code>server.properties</code>的内容  </p><hr><p>关于连接，如果是云服务器，在管理界面映射一下端口，然后在客户端的Minecraft中连接<code>域名:端口</code>即可</p><p>但是像笔者这样的物理服务器，或者说安装了Linux的设备，个人PC，在没有公网IP的情况下，就要继续内网穿透了  </p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>笔者在这里使用我的世界领域中比较有名且良心的<code>SakuraFrp</code>进行内网穿透，其它工具也大同小异</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Linux上的<code>SakuraFrp</code>是基于Docker运行的，所以下面我们先部署Docker，操作完全根据官方文档进行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install dnf-plugins-core</span><br><span class="line"><span class="built_in">sudo</span> dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>笔者在下面这遇到了安装速度十分缓慢，和下载失败的问题，重新执行命令再执行一次便解决了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>上面的这个<code>run hello-world</code>测试极有可能失败，下面来解决这个问题，参考了下面两篇文章：</p><p><a href="https://blog.csdn.net/Fengdf666/article/details/140236208">【完全解决】Docker安装完成运行hello-world镜像失败：Unable to find image ‘hello-world:latest‘ locallylatest:_unable to find image ‘hello-world:latest’ locally-CSDN博客</a></p><p><a href="https://www.cnblogs.com/paul-liang/p/18384633">Docker运行hello-world镜像失败或超时 - Paul7777 - 博客园</a>  </p><p>综合上面二者，最终是能解决问题的，先来配置<code>daemon</code>文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>复制下面的内容进去</p><ul><li>在笔者测试的时间(2025&#x2F;3&#x2F;19)下面的镜像源还是可用的</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://h59pkpv6.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://do.nark.eu.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://dc.j8.work&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>保存 + 退出，接下来重启docker，再执行一次测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>笔者到这就已经成功安装好docker了，若是测试仍不通过，请检查<code>daemon.json</code>的内容，是否少了或者多了逗号和括号</p><h3 id="SakuraFrp"><a href="#SakuraFrp" class="headerlink" title="SakuraFrp"></a>SakuraFrp</h3><p><code>SakuraFrp</code>在Linux上的部署，官方文档给出了详细的方案</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_203047.png" class=""><p>首先在终端以管理员身份运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;. &lt;(curl -sSL https://doc.natfrp.com/launcher.sh)&quot;</span></span><br></pre></td></tr></table></figure><p>安装好后，应该是会自动输出日志，并需要填写访问密钥，这个(或者说接下来的操作)可以在<code>SakuraFrp</code>官网的管理面板找到</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_203530.png" class=""><p>登录好之后就能看到其日志文件，下面是常规的启动并查看日志的操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start natfrp-service</span><br><span class="line">docker logs natfrp-service</span><br></pre></td></tr></table></figure><p>如图，接下来需要用物理方式操作下服务器</p><img src="/2025/03/19/Minecraft-server/Image_146159838978722.png" class=""><p>打开浏览器(一般Linux自带Firefox)访问“使用”后面的网址打开<code>WebUI</code></p><p>然后看到“隧道”那什么都没有，只有一个加号，这时我们在打开<code>SakuraFrp</code>的管理面板，找到服务下的<code>隧道列表</code>，新建两个隧道，如图所示：</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_204855.png" class=""><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_205010.png" class=""><p>第一个端口号为7102的是服务器上<code>SakuraFrp</code>的<code>WebUI</code>，以便远程管理</p><p>第二个端口号为25565的是Minecraft的服务器端</p><p>回到<code>WebUI</code>界面刷新一下就能看到刚刚创建好的两个隧道了，我们分别双击，然后回到终端的日志界面</p><img src="/2025/03/19/Minecraft-server/Image_146585201484185.png" class=""><p>如图的红色字符的链接，就是<code>WebUI</code>和Minecraft的远程访问链接，将Minecraft对应的复制到游戏中即可连接上</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大功告成！(笔者服务器出生地的截图 &gt;w&lt;)</p><img src="/2025/03/19/Minecraft-server/792C7ECDA8518FCCDC8FA8E5E4E726CF.png" class="">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2025/03/18/Redis/"/>
      <url>/2025/03/18/Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis（Remote Dictionary Server）是一个高性能的开源内存数据结构存储系统，常被用作数据库、缓存和消息代理。它由Salvatore Sanfilippo开发，支持多种数据结构，如字符串、哈希、列表、集合和有序集合等，具备丰富的数据操作能力。Redis以其超快的读写速度著称，因为数据主要存储在内存中，同时支持可选的磁盘持久化（如RDB快照和AOF日志）以保障数据可靠性。其内置功能还包括事务、发布&#x2F;订阅模式以及Lua脚本支持，使其应用场景广泛，从实时分析到会话管理均表现出色。此外，Redis支持主从复制和集群模式，具有良好的扩展性。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://zhuanlan.zhihu.com/p/411888708">知乎 超强、超详细Redis入门教程</a>  </p><p><a href="https://blog.csdn.net/wenwenaier/article/details/121878831">CSDN【Redis二三事】一套超详细的Redis学习教程（步骤图片+实操）—第一集</a></p><blockquote><p>详细，附有业务场景的实例</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis包含五大数据类型：字符串(<code>string</code>), 列表(<code>list</code>), 哈希(<code>hash</code>), 集合(<code>set</code>), 集合(<code>zset</code>)  </p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Redis 最基本的数据类型，每个键对应一个值，值可以是文本、数字或二进制数据，最大存储 512MB。支持字符串拼接、截取、递增递减等操作，适用于缓存数据、计数器（如访问量统计）、分布式锁等场景。  </p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">del key </span><br></pre></td></tr></table></figure><h5 id="添加修改多个数据"><a href="#添加修改多个数据" class="headerlink" title="添加修改多个数据"></a>添加修改多个数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset key1 value1 key2 value2...</span><br></pre></td></tr></table></figure><h5 id="获取多个数据"><a href="#获取多个数据" class="headerlink" title="获取多个数据"></a>获取多个数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mget key1 key2...</span><br></pre></td></tr></table></figure><h5 id="获取数据的字符个数"><a href="#获取数据的字符个数" class="headerlink" title="获取数据的字符个数"></a>获取数据的字符个数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strlen key</span><br><span class="line">//例如</span><br><span class="line">set name1 nosql</span><br><span class="line">strlen name1</span><br><span class="line">//输出为: 5</span><br></pre></td></tr></table></figure><h5 id="追加信息"><a href="#追加信息" class="headerlink" title="追加信息"></a>追加信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append key value</span><br><span class="line">//例如</span><br><span class="line">append name1 name</span><br><span class="line">get name1</span><br><span class="line">/*输出为: nosqlname*/</span><br></pre></td></tr></table></figure><h5 id="多数据操作与单数据操作"><a href="#多数据操作与单数据操作" class="headerlink" title="多数据操作与单数据操作"></a>多数据操作与单数据操作</h5><ul><li>单指令执行 n 条指令需要 n次发送 + n次处理 + n次返回</li><li>多指令执行 n 条指令需要 1次发送 + n次处理 + 1次返回</li><li>数据量较大时，多指令消耗的时间远远少于单指令</li></ul><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="设置数值数据增加-减少指定范围的值"><a href="#设置数值数据增加-减少指定范围的值" class="headerlink" title="设置数值数据增加&#x2F;减少指定范围的值"></a>设置数值数据增加&#x2F;减少指定范围的值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incrby key increment</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><h5 id="对字符串类型进行数值操作"><a href="#对字符串类型进行数值操作" class="headerlink" title="对字符串类型进行数值操作"></a>对字符串类型进行数值操作</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mynum &quot;2&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>遇到数值操作，redis会自动将字符串类型转换成数值  </p><h4 id="string类型数值操作的注意事项"><a href="#string类型数值操作的注意事项" class="headerlink" title="string类型数值操作的注意事项"></a>string类型数值操作的注意事项</h4><ul><li>数据操作不成功的反馈与数据正常操作之间的差异<ul><li>表示运行结果是否成功<ul><li>（integer）0-&gt;false 失败</li><li>（integer）1-&gt;true 成功</li></ul></li><li>表示运行结果值<ul><li>（integer）3-&gt;3      3个</li><li>（integer）1-&gt;1      1个</li></ul></li></ul></li><li>数据未获取到<ul><li>（’’nil’’）等同于’’null’’</li></ul></li><li>数据最大存储量<ul><li>512MB</li></ul></li><li>数值计算最大范围（’’java’’中的’’long’’的最大值）<ul><li>9223372036854775807</li></ul></li></ul><hr><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>类似于小型的键值存储，适用于存储结构化数据，如用户信息（ID、姓名、邮箱等），相比 <code>String</code> 类型更节省内存，因为多个字段共享同一个键。可以对字段进行单独操作，避免整体读取修改，适用于存储对象、会话信息等。  </p><h4 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset key field value //添加/修改数据</span><br><span class="line">hget key field //获取数据</span><br><span class="line">hgetall key</span><br><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure><h5 id="添加-修改多个数据"><a href="#添加-修改多个数据" class="headerlink" title="添加&#x2F;修改多个数据"></a>添加&#x2F;修改多个数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2</span><br></pre></td></tr></table></figure><h5 id="获取多个数据-1"><a href="#获取多个数据-1" class="headerlink" title="获取多个数据"></a>获取多个数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmget key field1 field2...</span><br></pre></td></tr></table></figure><h5 id="获取哈希表中字段的数量"><a href="#获取哈希表中字段的数量" class="headerlink" title="获取哈希表中字段的数量"></a>获取哈希表中字段的数量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><h5 id="获取哈希表中是否存在指定的字段"><a href="#获取哈希表中是否存在指定的字段" class="headerlink" title="获取哈希表中是否存在指定的字段"></a>获取哈希表中是否存在指定的字段</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="获取哈希表中所有字段名或字段值"><a href="#获取哈希表中所有字段名或字段值" class="headerlink" title="获取哈希表中所有字段名或字段值"></a>获取哈希表中所有字段名或字段值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure><h5 id="设置指定字段的数值数据增加指定范围的值"><a href="#设置指定字段的数值数据增加指定范围的值" class="headerlink" title="设置指定字段的数值数据增加指定范围的值"></a>设置指定字段的数值数据增加指定范围的值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby key field increment</span><br></pre></td></tr></table></figure><h5 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//建立哈希，并赋值</span><br><span class="line">127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 </span><br><span class="line">OK</span><br><span class="line">//列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;P1pp0&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br><span class="line">//更改哈希中的某一个值</span><br><span class="line">127.0.0.1:6379&gt; HSET user:001 password 12345 </span><br><span class="line">(integer) 0</span><br><span class="line">//再次列出哈希的内容</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:001 </span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;password&quot;</span><br><span class="line">4) &quot;12345&quot;</span><br><span class="line">5) &quot;age&quot;</span><br><span class="line">6) &quot;34&quot;</span><br></pre></td></tr></table></figure><h4 id="hash类型数据操作的注意事项"><a href="#hash类型数据操作的注意事项" class="headerlink" title="hash类型数据操作的注意事项"></a>hash类型数据操作的注意事项</h4><ul><li>1.<code>hash</code>类型下的<code>value</code><strong>只能存储字符串</strong>，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（<code>nil</code>）</li><li>2.每个<code>hash</code>可以存储2^23-1个键值对</li><li>3.<code>hash</code>类型十分贴近对象的数据存储形式，并且可以灵活添加对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，<strong>更不可以将hash作为对象列表使用</strong></li><li>4.<code>hgetall</code>操作可以获取全部属性，如果内部<code>field</code>过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈</li></ul><hr><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>基于双向链表实现，可以从头部（左侧）或尾部（右侧）快速插入和删除元素，同时支持指定范围的索引读取。适合实现消息队列、时间轴（如微博动态）、任务调度等应用，尤其适用于需要按照插入顺序处理数据的场景。</p><h4 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="添加-修改数据"><a href="#添加-修改数据" class="headerlink" title="添加&#x2F;修改数据"></a>添加&#x2F;修改数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush key value1 [value2]... //从左边进</span><br><span class="line">rpush key value1 [value2]... /*从右边进*/</span><br></pre></td></tr></table></figure><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>关于<code>lrange</code>:  </p><ul><li>lrange用来获取指定范围的元素  </li><li>-1 代表倒数第一个元素  </li><li>列表元素索引从位置0开始</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">lien key</span><br></pre></td></tr></table></figure><h5 id="获取并移除数据"><a href="#获取并移除数据" class="headerlink" title="获取并移除数据"></a>获取并移除数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure><h5 id="移除指定数据"><a href="#移除指定数据" class="headerlink" title="移除指定数据"></a>移除指定数据</h5><p>关于<code>lrem</code>:  </p><ul><li>参数<code>count</code><ul><li><code>count &gt; 0</code> → 从头（左侧）开始删除<code>count</code>个匹配的<code>value</code></li><li><code>count &lt; 0</code> → 从尾（右侧）开始删除<code>count</code>个匹配的<code>value</code></li><li><code>count = 0</code> → 删除**所有匹配的<code>value</code>**（等价于删除列表中所有该值的元素）</li></ul></li><li>如果<code>key</code>不存在<ul><li>返回 0</li></ul></li><li>常用于<strong>去除列表中的重复元素或清理数据</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><h4 id="扩展操作-2"><a href="#扩展操作-2" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="在规定时间内获取并移除数据"><a href="#在规定时间内获取并移除数据" class="headerlink" title="在规定时间内获取并移除数据"></a>在规定时间内获取并移除数据</h5><p>关于<code>blpop</code>:  </p><ul><li>参数<code>key1 [key2...]</code><ul><li>可以提供多个列表的键名，<code>Redis</code> 会按照顺序依次检查这些列表</li></ul></li><li>参数<code>timeout</code><ul><li>timeout &gt; 0 → 如果列表为空，则最多等待 <code>timeout</code> 秒</li><li>timeout &lt; 0 → 永远<strong>阻塞</strong>，直到有数据可用</li></ul></li><li>适用于<strong>任务队列、生产者-消费者模型</strong>等场景</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br></pre></td></tr></table></figure><p>示例  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RPUSH list1 &quot;a&quot; &quot;b&quot; &quot;c&quot;    // 列表内容：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;a&quot;，返回 [&quot;list1&quot;, &quot;a&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;b&quot;，返回 [&quot;list1&quot;, &quot;b&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;c&quot;，返回 [&quot;list1&quot;, &quot;c&quot;]</span><br><span class="line">BLPOP list1 10             /* 列表为空，阻塞最多 10 秒，若无新元素，则返回 nil */</span><br></pre></td></tr></table></figure><h5 id="综合示例-1"><a href="#综合示例-1" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新建一个list叫做mylist，并在列表头部插入元素&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist &quot;1&quot; </span><br><span class="line">//返回当前mylist中的元素个数</span><br><span class="line">(integer) 1 </span><br><span class="line">//在mylist右侧插入元素&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;2&quot; </span><br><span class="line">(integer) 2</span><br><span class="line">//在mylist左侧插入元素&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist &quot;0&quot; </span><br><span class="line">(integer) 3</span><br><span class="line">//列出mylist中从编号0到编号1的元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 1 </span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">//列出mylist中从编号0到倒数第一个元素</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1 </span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;2&quot;</span><br></pre></td></tr></table></figure><h4 id="list类型数据操作注意事项"><a href="#list类型数据操作注意事项" class="headerlink" title="list类型数据操作注意事项"></a>list类型数据操作注意事项</h4><ul><li>1.<code>list</code>中保存的数据都是<code>string</code>类型的，数据总容量是有限的，最多2^32-1个元素  </li><li>2.<code>list</code>具有’’索引’’的概念，但是操作数据时通常以’’队列’’的形式进行入队出队操作，或以’’栈’’的形式进行入栈出栈操作  </li><li>3.获取全部数据操作结束索引设置为-1  </li><li>4.<code>list</code>可以对数据进行<code>分页</code>操作，通常第1页的信息来自于<code>list</code>，第2页及更多的信息通过’’数据库’’的形式加载</li></ul><hr><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>由唯一无序的元素组成，支持 O(1) 时间复杂度的添加、删除和查找操作，并提供交集、并集、差集等集合运算，适用于去重、推荐系统中的共同关注、标签管理等应用。由于不允许重复元素，可以高效存储不重复的数据集合。</p><h4 id="基础操作-3"><a href="#基础操作-3" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd key member1 [member2]</span><br></pre></td></tr></table></figure><h5 id="获取全部数据"><a href="#获取全部数据" class="headerlink" title="获取全部数据"></a>获取全部数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srem key member1 [member2]</span><br></pre></td></tr></table></figure><h5 id="获取集合数据总量"><a href="#获取集合数据总量" class="headerlink" title="获取集合数据总量"></a>获取集合数据总量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure><h5 id="判断集合中是否包含指定数据"><a href="#判断集合中是否包含指定数据" class="headerlink" title="判断集合中是否包含指定数据"></a>判断集合中是否包含指定数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><h4 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h4><h5 id="随机获取集合中指定数量的数据"><a href="#随机获取集合中指定数量的数据" class="headerlink" title="随机获取集合中指定数量的数据"></a>随机获取集合中指定数量的数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure><h5 id="随机获取集合中的某个数据并将其移出集合"><a href="#随机获取集合中的某个数据并将其移出集合" class="headerlink" title="随机获取集合中的某个数据并将其移出集合"></a>随机获取集合中的某个数据并将其移出集合</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure><h5 id="求两个集合的交、并、差集"><a href="#求两个集合的交、并、差集" class="headerlink" title="求两个集合的交、并、差集"></a>求两个集合的交、并、差集</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinter key1 [key2]</span><br><span class="line">sunion key1 [key2]</span><br><span class="line">sdiff key1 [key2]</span><br></pre></td></tr></table></figure><h5 id="求两个集合的交、并、差集-并存储到指定集合中"><a href="#求两个集合的交、并、差集-并存储到指定集合中" class="headerlink" title="求两个集合的交、并、差集 并存储到指定集合中"></a>求两个集合的交、并、差集 并存储到指定集合中</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinterstore destination key1 [key2]</span><br><span class="line">sunionstore destination key1 [key2]</span><br><span class="line">sdiffstore destination key1 [key2]</span><br></pre></td></tr></table></figure><h5 id="将指定数据从原始集合中移动到目标集合中"><a href="#将指定数据从原始集合中移动到目标集合中" class="headerlink" title="将指定数据从原始集合中移动到目标集合中"></a>将指定数据从原始集合中移动到目标集合中</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove source destination member</span><br></pre></td></tr></table></figure><h5 id="综合示例-2"><a href="#综合示例-2" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//向集合myset中加入一个新元素&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;one&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;two&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">//列出集合myset中的所有元素</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">//判断元素1是否在集合myset中，返回1表示存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset &quot;one&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">//判断元素3是否在集合myset中，返回0表示不存在</span><br><span class="line">127.0.0.1:6379&gt; sismember myset &quot;three&quot; </span><br><span class="line">(integer) 0</span><br><span class="line">//新建一个新的集合yourset</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset &quot;1&quot; </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd yourset &quot;2&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers yourset</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">//对两个集合求并集</span><br><span class="line">127.0.0.1:6379&gt; sunion myset yourset </span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line">3) &quot;2&quot;</span><br><span class="line">4) &quot;two&quot;</span><br></pre></td></tr></table></figure><h4 id="set类型数据操作的注意事项"><a href="#set类型数据操作的注意事项" class="headerlink" title="set类型数据操作的注意事项"></a>set类型数据操作的注意事项</h4><ul><li>set类型<code>不允许数据重复</code>，如果添加的数据在set中已经存在，将只<code>保留一份</code></li><li>set虽然和hash的<code>存储结构相同</code>，但是<code>无法启用hash中存储值的空间</code></li></ul><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>在 Set 的基础上增加了一个分数（score），并按分数排序，支持范围查询、按分数排名等操作。适用于排行榜（如游戏积分榜）、优先级队列（如定时任务）、时间排序数据存储（如文章阅读量排名）等需要按权重排序的场景。</p><h4 id="基础操作-4"><a href="#基础操作-4" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]</span><br></pre></td></tr></table></figure><h5 id="获取全部数据-1"><a href="#获取全部数据-1" class="headerlink" title="获取全部数据"></a>获取全部数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]     //按从小到大的顺序展示</span><br><span class="line">zrevrange key start stop [WITHSCORES]  //按从大到小的顺序展示</span><br></pre></td></tr></table></figure><h5 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem key member [member...]</span><br></pre></td></tr></table></figure><h5 id="按条件获取数据"><a href="#按条件获取数据" class="headerlink" title="按条件获取数据"></a>按条件获取数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrangebyscore key min max [Withscores][limit]</span><br><span class="line">zrevrangebyscore key max min [withscores]</span><br></pre></td></tr></table></figure><h5 id="按条件删除数据"><a href="#按条件删除数据" class="headerlink" title="按条件删除数据"></a>按条件删除数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zremrangebyrank key start stop  //按索引删除</span><br><span class="line">zremrangebyscore key min max //按范围删除</span><br></pre></td></tr></table></figure><h5 id="综合示例-3"><a href="#综合示例-3" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 1 baidu.com </span><br><span class="line">(integer) 1</span><br><span class="line">//向myzset中新增一个元素360.com，赋予它的序号是3</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 3 360.com </span><br><span class="line">(integer) 1</span><br><span class="line">//向myzset中新增一个元素google.com，赋予它的序号是2</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 2 google.com </span><br><span class="line">(integer) 1</span><br><span class="line">//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。</span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 with scores </span><br><span class="line">1) &quot;baidu.com&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;google.com&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;360.com&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">//只列出myzset的元素</span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 </span><br><span class="line">1) &quot;baidu.com&quot;</span><br><span class="line">2) &quot;google.com&quot;</span><br><span class="line">3) &quot;360.com&quot;</span><br></pre></td></tr></table></figure><h4 id="进阶操作-1"><a href="#进阶操作-1" class="headerlink" title="进阶操作"></a>进阶操作</h4><h5 id="获取集合数据总量-1"><a href="#获取集合数据总量-1" class="headerlink" title="获取集合数据总量"></a>获取集合数据总量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcard key</span><br><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><h5 id="集合交、并集操作"><a href="#集合交、并集操作" class="headerlink" title="集合交、并集操作"></a>集合交、并集操作</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key [key …]</span><br><span class="line">zunionstore destination numkeys key [key …]</span><br></pre></td></tr></table></figure><h4 id="sorted-set类型数据操作的注意事项"><a href="#sorted-set类型数据操作的注意事项" class="headerlink" title="sorted_set类型数据操作的注意事项"></a>sorted_set类型数据操作的注意事项</h4><p>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992<br>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重<br>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/03/17/MySQL/"/>
      <url>/2025/03/17/MySQL/</url>
      
        <content type="html"><![CDATA[<p>MySQL 是一个广受欢迎的开源关系型数据库管理系统（RDBMS），由瑞典公司 MySQL AB 开发，现由 Oracle 维护。它基于结构化查询语言（SQL），适用于管理大规模结构化数据，支持多种操作系统，如 Windows、Linux 和 macOS。MySQL 以其高性能、可靠性和易用性著称，提供丰富的功能，包括事务支持、索引优化、多表连接以及用户权限管理。其核心特点是支持多种存储引擎（如 InnoDB 和 MyISAM），允许用户根据需求灵活选择。此外，MySQL 提供主从复制、分区和集群（如 MySQL Cluster）等功能，适用于高可用性和分布式场景。从 Web 应用后台到企业级数据仓库，MySQL 的应用范围广泛。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="http://xuesql.cn/">自学SQL网(教程 视频 练习全套)</a></p><blockquote><p>学完知识就有题做</p></blockquote><hr><p><a href="https://www.zhihu.com/question/30357711"></a></p><p><a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程 | 菜鸟教程</a></p><p><a href="https://blog.csdn.net/weixin_43896929/article/details/120750965">MySQL总结_sq连表-CSDN博客</a></p><p><a href="https://liaoxuefeng.com/books/sql/relational/primary-key/index.html">主键 - SQL教程 - 廖雪峰的官方网站</a></p><blockquote><p>观感最好的教程</p></blockquote><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><blockquote><p>引用自 <a href="https://liaoxuefeng.com/books/sql/relational/index.html">关系模型 - SQL教程 - 廖雪峰的官方网站</a></p></blockquote><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th>id</th><th>class id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr></tbody></table><p>对于关系表，有个很重要的约束，就是<strong>任意两条记录不能重复</strong>。不能重复不是指两条记录不完全相同，而是指<strong>能够通过某个字段唯一区分出不同的记录</strong>，这个字段被称为<em><strong>主键</strong></em>。</p><p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为<strong>插入相同主键的两条记录是不被允许的</strong>。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，<strong>主键最好不要再修改，因为主键是用来唯一定位记录的</strong>，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><blockquote><p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。  </p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>小红</td><td>…</td></tr></tbody></table><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>…</td></tr><tr><td>2</td><td>二班</td><td>…</td></tr></tbody></table><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>…</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>…</td></tr></tbody></table><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，<strong>可以把数据与另一张表关联起来</strong>，这种列称为<code>外键</code>。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过对数据库表创建索引，可以提高查询速度；</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性；</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h2 id="SELECT-查询"><a href="#SELECT-查询" class="headerlink" title="SELECT 查询"></a>SELECT 查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> another_condition</span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> …;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> movies </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">year</span><span class="operator">&gt;=</span><span class="number">2010</span> <span class="keyword">AND</span> length_minutes<span class="operator">&lt;</span><span class="number">120</span>;</span><br></pre></td></tr></table></figure><h3 id="筛选数字属性列"><a href="#筛选数字属性列" class="headerlink" title="筛选数字属性列"></a><strong>筛选数字属性列</strong></h3><table><thead><tr><th>关键字</th><th></th><th>例</th></tr></thead><tbody><tr><td>&#x3D;, !&#x3D;, &lt; &lt;&#x3D;, &gt;, ≥</td><td></td><td>col_name !&#x3D; 4</td></tr><tr><td>BETWEEN … AND …</td><td>在两个数之间</td><td>col_name BETWEEN 1.5 AND 10.5</td></tr><tr><td>NOT BETWEEN … AND …</td><td></td><td>col_name NOT BETWEEN 1 AND 10</td></tr><tr><td>IN (…)</td><td>在一个列表</td><td>col_name IN (2, 4, 6)</td></tr><tr><td>NOT IN (…)</td><td></td><td>col_name NOT IN (1, 3, 5)</td></tr></tbody></table><h3 id="筛选字符串属性列"><a href="#筛选字符串属性列" class="headerlink" title="筛选字符串属性列"></a><strong>筛选字符串属性列</strong></h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>&#x3D;</td><td>完全等于</td><td></td></tr><tr><td>!&#x3D; or &lt;&gt;</td><td>不等于</td><td></td></tr><tr><td>LIKE</td><td>没有用通配符等价于 &#x3D;</td><td></td></tr><tr><td>NOT LIKE</td><td>没有用通配符等价于 !&#x3D;</td><td></td></tr><tr><td>%</td><td>通配符</td><td>col_name LIKE “%AT%”</td></tr><tr><td>_(下划线)</td><td></td><td>col_name LIKE “AN_”</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*通配符*/</span></span><br><span class="line">col_name <span class="keyword">LIKE</span> &quot;%AT%&quot;;</span><br><span class="line"><span class="comment">/*&quot;AT&quot;&quot;AT*...&quot;&quot;...*AT&quot;&quot;...*AT*...&quot;均满足条件</span></span><br><span class="line"><span class="comment"> &quot;AT&quot;前后可以有任意字符*/</span></span><br><span class="line">col_name <span class="keyword">LIKE</span> &quot;AN_&quot;;</span><br><span class="line"><span class="comment">/*&quot;AND&quot;可以 &quot;AN&quot;&quot;ANDD&quot;均不行</span></span><br><span class="line"><span class="comment"> 与&#x27;%&#x27;相似 但只代表一个字符*/</span></span><br></pre></td></tr></table></figure><h3 id="过滤-排序"><a href="#过滤-排序" class="headerlink" title="过滤&#x2F;排序"></a>过滤&#x2F;排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*用DISTINCT关键字来指定某个或某些属性列唯一返回*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*让结果按一个或多个属性列做排序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="comment">/* ASC 升序或 DESC 降序*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line"><span class="comment">/*LIMIT来指定只返回多少行结果 </span></span><br><span class="line"><span class="comment"> 用OFFSET来指定从哪一行开始返回*/</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br><span class="line"><span class="comment">/*关于OFFSET 若要输出第N行(及之后)</span></span><br><span class="line"><span class="comment">  则OFFSET的参数须为N-1 */</span></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_132438.png" class="" title="例题1"><hr><h3 id="SELECT复习题"><a href="#SELECT复习题" class="headerlink" title="SELECT复习题"></a>SELECT复习题</h3><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_134213.png" class="" title="例题2"><hr><h3 id="在查询中使用表达式"><a href="#在查询中使用表达式" class="headerlink" title="在查询中使用表达式"></a><strong>在查询中使用表达式</strong></h3><p>实际上AS不仅用在表达式别名上，普通的属性列甚至是表（table）都可以取一个别名，这让SQL更容易理解</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--属性列和表取别名的例子</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">AS</span> better_column_name, …</span><br><span class="line"><span class="keyword">FROM</span> a_long_widgets_table_name <span class="keyword">AS</span> mywidgets</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> widget_sales</span><br><span class="line">  <span class="keyword">ON</span> mywidgets.id <span class="operator">=</span> widget_sales.widget_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--包含表达式的例子</span></span><br><span class="line"><span class="keyword">SELECT</span>  particle_speed <span class="operator">/</span> <span class="number">2.0</span> <span class="keyword">AS</span> half_particle_speed <span class="comment">--对结果做了一个除2</span></span><br><span class="line"><span class="keyword">FROM</span> physics_data</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">ABS</span>(particle_position) <span class="operator">*</span> <span class="number">10.0</span> <span class="operator">&gt;</span><span class="number">500</span></span><br><span class="line">            <span class="comment">--（条件要求这个属性绝对值乘以10大于500）;</span></span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-13_164705.png" class="" title="例题3"><hr><h3 id="在查询中进行统计"><a href="#在查询中进行统计" class="headerlink" title="在查询中进行统计"></a><strong>在查询中进行统计</strong></h3><img src="/2025/03/17/MySQL/v2-89b10c80ff69acdb02494042f55c59d2_1440w.webp" class="" title="样图1"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGG_FUNC(column_or_expression) <span class="keyword">AS</span> aggregate_description, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> constraint_expression;</span><br></pre></td></tr></table></figure><p>常用统计函数:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>COUNT(*) COUNT(column)</td><td>计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数</td></tr><tr><td>MIN(column)</td><td>找column最小的一行</td></tr><tr><td>MAX(column)</td><td>找column最大的一行</td></tr><tr><td>AVG(column)</td><td>对column所有行取平均值</td></tr><tr><td>SUM(column)</td><td>对column所有行求和</td></tr></tbody></table><hr><h3 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h3><p><code>GROUP BY</code> 数据分组语法可以按某个<code>col_name</code>对数据进行分组，如：<code>GROUP BY Year</code>指对数据按年份分组， 相同年份的分到一个组里。如果把统计函数和<code>GROUP BY</code>结合，那统计结果就是对分组内的数据统计了<br><code>GROUP BY</code> 分组结果的数据条数，就是分组数量，比如：<code>GROUP BY Year</code>，全部数据里有几年，就返回几条数据， 不管是否应用了统计函数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--用分组的方式统计</span></span><br><span class="line"><span class="keyword">SELECT</span> AGG_FUNC(column_or_expression) <span class="keyword">AS</span> aggregate_description, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> constraint_expression</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span>;</span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-13_170736.png" class="" title="例题4"><p>在 <strong><code>GROUP BY</code></strong> 分组语法中，我们知道数据库是先对数据做 <strong><code>WHERE</code></strong> ，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？<br>一个不常用的语法 <strong><code>HAVING</code></strong> 语法将用来解决这个问题，他可以对分组之后的数据再做<code>SELECT</code>筛选</p><p><strong><code>HAVING</code></strong> 和 <strong><code>WHERE</code></strong> 语法一样，只不过作用的结果集不一样. 在我们例子数据表数据量小的情况下可能感觉 <strong><code>HAVING</code></strong> 没有什么用，但当你的数据量成千上万属性又很多时也许能帮上大忙</p><hr><h3 id="JOIN-连接"><a href="#JOIN-连接" class="headerlink" title="JOIN 连接"></a>JOIN 连接</h3><h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的重复数据降到最少(这有助于数据的一致性维护)同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长(ie. 比如汽车引擎的增长和汽车的增长是完全独立的)  </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_table_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable <span class="comment">--主表</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> another_table <span class="comment">--要连接的表</span></span><br><span class="line">    <span class="keyword">ON</span> mytable.id <span class="operator">=</span> another_table.id </span><br><span class="line">    <span class="comment">--想象一下刚才讲的主键连接，两个相同的连成1条</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>, … <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br></pre></td></tr></table></figure><p>本例中<code>ON</code>条件描述的关联关系:</p><h4 id="INNER-JOIN-内-连接"><a href="#INNER-JOIN-内-连接" class="headerlink" title="INNER JOIN (内)连接"></a><strong><code>INNER JOIN</code></strong> (内)连接</h4><p> 先将两个表数据连接到一起，两个表中如果通过ID互相找不到的数据将会舍弃。此时，你可以将连表后的数据看作两个表的合并，SQL中的其他语句会在这个合并基础上 继续执行(想一下和之前的单表操作就一样了)<br>还有一个理解 <strong><code>INNER JOIN</code></strong> 的方式，就是把 <strong><code>INNER JOIN</code></strong> 想成两个集合的交集。</p><p><img src="C:/Users/Kawauso/Documents/Blogs/source/_posts/MySQL/Screenshot_2025-03-11_142245.png" alt="例题5"></p><h4 id="OUTER-JOIN外连接"><a href="#OUTER-JOIN外连接" class="headerlink" title="OUTER JOIN外连接"></a><code>OUTER JOIN</code>外连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--用LEFT/RIGHT/FULL JOINs 做多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">INNER</span><span class="operator">/</span><span class="keyword">LEFT</span><span class="operator">/</span><span class="keyword">RIGHT</span><span class="operator">/</span><span class="keyword">FULL</span> <span class="keyword">JOIN</span> another_table</span><br><span class="line">    <span class="keyword">ON</span> mytable.id <span class="operator">=</span> another_table.matching_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>, … <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br></pre></td></tr></table></figure><p>在表A 连接 B， <strong><code>LEFT JOIN</code></strong> 保留A的所有行，不管有没有能匹配上B，反过来 <strong><code>RIGHT JOIN</code><strong>则保留所有B里的行。最后</strong><code>FULL JOIN</code></strong> 不管有没有匹配上，同时保留A和B里的所有行</p><p>将两个表数据1-1连接，保留A或B的原有行，如果某一行在另一个表不存在，会用 <code>NULL</code>来填充结果数据。</p><p><img src="C:/Users/Kawauso/Documents/Blogs/source/_posts/MySQL/Screenshot_2025-03-11_151348.png" alt="例题6"></p><hr><h3 id="查询执行顺序"><a href="#查询执行顺序" class="headerlink" title="查询执行顺序"></a>查询执行顺序</h3><img src="/2025/03/17/MySQL/v2-d414289449f1dcaaa8c81e13de989b57_1440w.webp" class="" title="样图2"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--这才是完整的SELECT查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">column</span>, AGG_FUNC(column_or_expression), …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">    <span class="keyword">JOIN</span> another_table</span><br><span class="line">      <span class="keyword">ON</span> mytable.column <span class="operator">=</span> another_table.column</span><br><span class="line">    <span class="keyword">WHERE</span> constraint_expression</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">    <span class="keyword">HAVING</span> constraint_expression</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">    LIMIT count <span class="keyword">OFFSET</span> COUNT;</span><br></pre></td></tr></table></figure><h4 id="1-FROM-和-JOIN"><a href="#1-FROM-和-JOIN" class="headerlink" title="1. FROM 和 JOIN"></a>1. <code>FROM</code> 和 <code>JOIN</code></h4><p><strong><code>FROM</code></strong> 或  <strong><code>JOIN</code></strong> 会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表）</p><h4 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a><strong>2. <code>WHERE</code></strong></h4><p>我们确定了数据来源 <strong><code>WHERE</code></strong> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自 <strong><code>FROM</code></strong> 圈定的表. <code>AS</code>别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h4 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a><strong>3. <code>GROUP BY</code></strong></h4><p>如果你用了 <strong><code>GROUP BY</code></strong> 分组，那 <strong><code>GROUP BY</code></strong> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h4 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a><strong>4. <code>HAVING</code></strong></h4><p>如果你用了 <strong><code>GROUP BY</code></strong> 分组, <strong><code>HAVING</code></strong> 会在分组完成后对结果集再次筛选。<code>AS</code>别名也不能在这个阶段使用.</p><h4 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a><strong>5. <code>SELECT</code></strong></h4><p>确定结果之后， <strong><code>SELECT</code></strong> 用来对结果col简单筛选或计算，决定输出什么数据.</p><h4 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a><strong>6. <code>DISTINCT</code></strong></h4><p>如果数据行有重复 <strong><code>DISTINCT</code></strong> 将负责排重.</p><h4 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a><strong>7. <code>ORDER BY</code></strong></h4><p>在结果集确定的情况下， <strong><code>ORDER BY</code></strong> 对结果做排序。因为 <strong><code>SELECT</code></strong> 中的表达式已经执行完了。此时可以用<code>AS</code>别名.</p><h4 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT &#x2F; OFFSET"></a><strong>8. <code>LIMIT</code> &#x2F; <code>OFFSET</code></strong></h4><p>最后 <strong><code>LIMIT</code></strong> 和 <strong><code>OFFSET</code></strong> 从排序的结果中截取部分数据.</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p><hr><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>如果某个字段你没有填写到数据库，很可能就会出现 <strong><code>NULL</code></strong>  。所有一个常见的方式就是为字段设置 <strong><code>默认值</code></strong> ,比如 数字的默认值设置为0，字符串设置为  <code>&quot;&quot;</code> 字符串. 但是在一些 <strong><code>NULL</code></strong> 表示它本来含义的场景，需要注意是否设置默认值还是保持 <strong><code>NULL</code></strong> 。 (比如, 当你计算一些行的平均值的时候，如果是0会参与计算导致平均值差错，是  <strong><code>NULL</code></strong> 则不会参与计算).</p><p>还有一些情况很难避免 <strong><code>NULL</code></strong> 的出现, 比如之前说的 outer-joining 多表连接，A和B有数据差异时，必须用 <strong><code>NULL</code></strong> 来填充。这种情况，可以用 <strong><code>IS NULL</code></strong> 和 <strong><code>IS NOT NULL</code></strong> 来选在某个字段是否等于 <strong><code>NULL</code></strong>.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">IS</span><span class="operator">/</span><span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> another_condition</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> …;</span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_203039.png" class="" title="例题7"><hr><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><blockquote><p>部分引用自 <a href="https://liaoxuefeng.com/books/sql/manipulation/index.html">修改数据 - SQL教程 - 廖雪峰的官方网站</a></p></blockquote><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h4 id="INSERT-插入"><a href="#INSERT-插入" class="headerlink" title="INSERT 插入"></a>INSERT 插入</h4><p>引用于 <a href="https://www.runoob.com/mysql/mysql-insert-query.html">MySQL 插入数据 | 菜鸟教程</a></p><p>例如，我们向<code>user</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> users (username, email, birthdate, is_active)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test@runoob.com&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>如果要插入所有列(即插入行)的数据，可以省略列名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">NULL</span>,<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test@runoob.com&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (username, email, birthdate, is_active)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;test1@runoob.com&#x27;</span>, <span class="string">&#x27;1985-07-10&#x27;</span>, <span class="literal">true</span>),</span><br><span class="line">    (<span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;test2@runoob.com&#x27;</span>, <span class="string">&#x27;1988-11-25&#x27;</span>, <span class="literal">false</span>),</span><br><span class="line">    (<span class="string">&#x27;test3&#x27;</span>, <span class="string">&#x27;test3@runoob.com&#x27;</span>, <span class="string">&#x27;1993-05-03&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h3><p><a href="https://www.runoob.com/mysql/mysql-update-query.html">MySQL UPDATE 更新 | 菜鸟教程</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>table_name</code> 是你要更新数据的表的名称。</li><li><code>column1</code>, <code>column2</code>, … 是你要更新的列的名称。</li><li><code>value1</code>, <code>value2</code>, … 是新的值，用于替换旧的值。</li><li><code>WHERE condition</code> 是一个可选的子句，用于指定更新的行。如果省略 <code>WHERE</code> 子句，将更新表中的所有行。</li></ul><p><strong>更多说明：</strong></p><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 <code>WHERE</code> 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p>当你需要更新数据表中指定行的数据时 <code>WHERE</code> 子句是非常有用的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--更新单个列的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">60000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--更新多个列的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders</span><br><span class="line"><span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span>, ship_date <span class="operator">=</span> <span class="string">&#x27;2023-03-01&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用表达式更新值</span></span><br><span class="line"><span class="keyword">UPDATE</span> products</span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> price <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--更新使用子查询的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> total_purchases <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount)</span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">WHERE</span> orders.customer_id <span class="operator">=</span> customers.customer_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> customer_type <span class="operator">=</span> <span class="string">&#x27;Premium&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，更新<code>id=1</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p><p>当更新<code>id=999</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p><hr><h3 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE 删除"></a>DELETE 删除</h3><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除id=1的记录:</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录:</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除id=999的记录:</span><br><span class="line">DELETE FROM students WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。 </p><p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><hr><h2 id="CREATE-创建"><a href="#CREATE-创建" class="headerlink" title="CREATE 创建"></a>CREATE 创建</h2><p><a href="https://www.runoob.com/mysql/mysql-create-tables.html">MySQL 创建数据表 | 菜鸟教程</a></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--用户表实例</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    birthdate <span class="type">DATE</span>,</span><br><span class="line">    is_active <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实例解析：</p><ul><li><code>id</code>: 用户 id，整数类型，自增长，作为主键。</li><li><code>username</code>: 用户名，变长字符串，不允许为空。</li><li><code>email</code>: 用户邮箱，变长字符串，不允许为空。</li><li><code>birthdate</code>: 用户的生日，日期类型。</li><li><code>is_active</code>: 用户是否已经激活，布尔类型，默认值为 true。</li></ul><p>以上只是一个简单的实例，用到了一些常见的数据类型包括<code>INT</code>, <code>VARCHAR</code>, <code>DATE</code>, <code>BOOLEAN</code>，可以根据实际需要选择不同的数据类型。</p><p><code>AUTO_INCREMENT</code> 关键字用于创建一个自增长的列，<code>PRIMARY KEY</code> 用于定义主键。</p><p>如果希望在创建表时指定数据引擎，字符集和排序规则等，可以使用 <strong><code>CHARACTER SET</code></strong> 和 <strong><code>COLLATE</code></strong> 子句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> mytable (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/17/hello-world/"/>
      <url>/2025/03/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
