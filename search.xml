<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Linux(CentOS)系统上部署Minecraft服务器</title>
      <link href="/2025/03/19/Minecraft-server/"/>
      <url>/2025/03/19/Minecraft-server/</url>
      
        <content type="html"><![CDATA[<p>笔者近日配置好了物理服务器，便想利用起来建一个我的世界服务器，经熬夜研究后成功，将本攻略分享出来，希望能帮到大家，尤其是没有公网环境的Linux用户(像我一样)</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://docs.redhat.com/zh-cn/documentation/red_hat_build_of_openjdk/21/html-single/installing_and_using_red_hat_build_of_openjdk_21_on_rhel/index#installing-jre-on-rhel-using-yum_openjdk">在 RHEL 上安装并使用红帽构建的 OpenJDK 21 | Red Hat Product Documentation</a></p><p><a href="https://doc.natfrp.com/launcher/usage.html">SakuraFrp 启动器安装 &#x2F; 使用指南 | SakuraFrp 帮助文档</a></p><p><a href="https://docs.docker.com/engine/install/centos/">CentOS | Docker Docs</a></p><p><a href="https://www.bilibili.com/video/BV1iv4y1P7wJ/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=c8beb52bf015e61e5378008c684545a4">Linux终端开服教程★无面板★Minecraft_哔哩哔哩_bilibili</a></p><ul><li>来自B站的UP主<code>翱翔大使</code>，是全篇的主要思路来源</li></ul><h2 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h2><p>运行我的世界需要，须对应版本的Java环境，笔者这里安装的是OpenJDK21</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install java-21-openjdk</span><br><span class="line">java -version //验证是否成功安装</span><br></pre></td></tr></table></figure><p>如果服务器有多个Java版本，可以用<code>alternatives</code>进行版本切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure><p>如图，我们输入<code>2</code>并回车，就切换到了需要的版本</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_191616.png" class="" title="Java"><h2 id="游戏部署"><a href="#游戏部署" class="headerlink" title="游戏部署"></a>游戏部署</h2><p>首先在下面这个网址下载Minecraft的服务器端，这里我下的是支持Fabric的Banner(1.20.1)</p><p>[MohistMC](<a href="https://www.mohistmc.com/">MohistMC - 主页</a>)</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_185204.png" class=""><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_185231.png" class=""><p>下载完成后是个类似<code>banner-1.20.1-800-server.jar</code>的文件，接下来打开SSH软件，在服务器上操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/username //切换到个人文件夹或者想安装的位置</span><br><span class="line"><span class="built_in">mkdir</span> Minecraft //创建存放游戏的文件夹</span><br><span class="line"><span class="built_in">cd</span> Minecraft</span><br></pre></td></tr></table></figure><p>我们用SSH软件中的SFTP功能(或其他文件传输功能)，将刚才的游戏文件<code>banner-1.20.1-800-server.jar</code>拷贝到新建的文件夹<code>/home/username/Mineraft</code>中  </p><p>接着我们来写一个服务器的启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano start.sh</span><br></pre></td></tr></table></figure><p>其中内容如下填写，但注意各参数的作用</p><ul><li><code>-Xmx</code>是最大分配内存，<code>-Xms</code>是最小分配内存，笔者有32GB内存，为游戏分配了6G(其实可以多分点)</li><li><code>banner-1.20.1-800-server.jar</code>是刚才下载的游戏文件名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx6144M -Xms6144m -jar banner-1.20.1-800-server.jar</span><br><span class="line"><span class="built_in">stty</span> <span class="built_in">echo</span></span><br></pre></td></tr></table></figure><p>按<code>Ctrl + O</code>写入，<code>Enter</code>确认写入，<code>Ctrl + X</code>退出</p><p>接着为<code>start.sh</code>赋权，避免无权限访问的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 start.sh</span><br></pre></td></tr></table></figure><p>然后安装<code>screen</code>，简单来说，<code>screen</code>是帮用户创建独立会话，并可以随时恢复的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install screen</span><br></pre></td></tr></table></figure><p>  <code>screen</code>有如下几个常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen -S [name] //新建名为<span class="string">&quot;name&quot;</span>的screen</span><br><span class="line">screen -<span class="built_in">ls</span> //列出所有运行中的screen的名称和端口</span><br><span class="line">screen -r [port] //返回端口号为port的screen</span><br></pre></td></tr></table></figure><p>接着，新建一个<code>screen</code>运行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S Minecraft</span><br></pre></td></tr></table></figure><p>在新出现的会话中，运行<code>start.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure><p>然后一路顺畅，笔者在这里没有遇到报错，最后来到<code>...EULA...</code>让我们同意EULA协议，输入<code>true</code>后回车，等待一下，游戏服务器就在<code>25565</code>端口上成功运行了</p><p>若想离开Minecraft的这个<code>screen</code>按下<code>Ctrl+A+D</code>即可</p><p>关于游戏规则的更改(比如”是否允许非正版玩家加入“)，需要修改<code>server.properties</code>的内容  </p><hr><p>关于连接，如果是云服务器，在管理界面映射一下端口，然后在客户端的Minecraft中连接<code>域名:端口</code>即可</p><p>但是像笔者这样的物理服务器，或者说安装了Linux的设备，个人PC，在没有公网IP的情况下，就要继续内网穿透了  </p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>笔者在这里使用我的世界领域中比较有名且良心的<code>SakuraFrp</code>进行内网穿透，其它工具也大同小异</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Linux上的<code>SakuraFrp</code>是基于Docker运行的，所以下面我们先部署Docker，操作完全根据官方文档进行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf -y install dnf-plugins-core</span><br><span class="line"><span class="built_in">sudo</span> dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>笔者在下面这遇到了安装速度十分缓慢，和下载失败的问题，重新执行命令再执行一次便解决了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>上面的这个<code>run hello-world</code>测试极有可能失败，下面来解决这个问题，参考了下面两篇文章：</p><p><a href="https://blog.csdn.net/Fengdf666/article/details/140236208">【完全解决】Docker安装完成运行hello-world镜像失败：Unable to find image ‘hello-world:latest‘ locallylatest:_unable to find image ‘hello-world:latest’ locally-CSDN博客</a></p><p><a href="https://www.cnblogs.com/paul-liang/p/18384633">Docker运行hello-world镜像失败或超时 - Paul7777 - 博客园</a>  </p><p>综合上面二者，最终是能解决问题的，先来配置<code>daemon</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>复制下面的内容进去</p><ul><li>在笔者测试的时间(2025&#x2F;3&#x2F;19)下面的镜像源还是可用的</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://h59pkpv6.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://do.nark.eu.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://dc.j8.work&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>保存 + 退出，接下来重启docker，再执行一次测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>笔者到这就已经成功安装好docker了，若是测试仍不通过，请检查<code>daemon.json</code>的内容，是否少了或者多了逗号和括号</p><h3 id="SakuraFrp"><a href="#SakuraFrp" class="headerlink" title="SakuraFrp"></a>SakuraFrp</h3><p><code>SakuraFrp</code>在Linux上的部署，官方文档给出了详细的方案</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_203047.png" class=""><p>首先在终端以管理员身份运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;. &lt;(curl -sSL https://doc.natfrp.com/launcher.sh)&quot;</span></span><br></pre></td></tr></table></figure><p>安装好后，应该是会自动输出日志，并需要填写访问密钥，这个(或者说接下来的操作)可以在<code>SakuraFrp</code>官网的管理面板找到</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_203530.png" class=""><p>登录好之后就能看到其日志文件，下面是常规的启动并查看日志的操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start natfrp-service</span><br><span class="line">docker logs natfrp-service</span><br></pre></td></tr></table></figure><p>如图，接下来需要用物理方式操作下服务器</p><img src="/2025/03/19/Minecraft-server/Image_146159838978722.png" class=""><p>打开浏览器(一般Linux自带Firefox)访问“使用”后面的网址打开<code>WebUI</code></p><p>然后看到“隧道”那什么都没有，只有一个加号，这时我们在打开<code>SakuraFrp</code>的管理面板，找到服务下的<code>隧道列表</code>，新建两个隧道，如图所示：</p><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_204855.png" class=""><img src="/2025/03/19/Minecraft-server/Screenshot_2025-03-19_205010.png" class=""><p>第一个端口号为7102的是服务器上<code>SakuraFrp</code>的<code>WebUI</code>，以便远程管理</p><p>第二个端口号为25565的是Minecraft的服务器端</p><p>回到<code>WebUI</code>界面刷新一下就能看到刚刚创建好的两个隧道了，我们分别双击，然后回到终端的日志界面</p><img src="/2025/03/19/Minecraft-server/Image_146585201484185.png" class=""><p>如图的红色字符的链接，就是<code>WebUI</code>和Minecraft的远程访问链接，将Minecraft对应的复制到游戏中即可连接上</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大功告成！(笔者服务器出生地的截图 &gt;w&lt;)</p><img src="/2025/03/19/Minecraft-server/792C7ECDA8518FCCDC8FA8E5E4E726CF.png" class="">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2025/03/18/Redis/"/>
      <url>/2025/03/18/Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis（Remote Dictionary Server）是一个高性能的开源内存数据结构存储系统，常被用作数据库、缓存和消息代理。它由Salvatore Sanfilippo开发，支持多种数据结构，如字符串、哈希、列表、集合和有序集合等，具备丰富的数据操作能力。Redis以其超快的读写速度著称，因为数据主要存储在内存中，同时支持可选的磁盘持久化（如RDB快照和AOF日志）以保障数据可靠性。其内置功能还包括事务、发布&#x2F;订阅模式以及Lua脚本支持，使其应用场景广泛，从实时分析到会话管理均表现出色。此外，Redis支持主从复制和集群模式，具有良好的扩展性。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://zhuanlan.zhihu.com/p/411888708">知乎 超强、超详细Redis入门教程</a>  </p><p><a href="https://blog.csdn.net/wenwenaier/article/details/121878831">CSDN【Redis二三事】一套超详细的Redis学习教程（步骤图片+实操）—第一集</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis包含五大数据类型：字符串(<code>string</code>), 列表(<code>list</code>), 哈希(<code>hash</code>), 集合(<code>set</code>), 集合(<code>zset</code>)  </p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Redis 最基本的数据类型，每个键对应一个值，值可以是文本、数字或二进制数据，最大存储 512MB。支持字符串拼接、截取、递增递减等操作，适用于缓存数据、计数器（如访问量统计）、分布式锁等场景。  </p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">del key </span><br></pre></td></tr></table></figure><h5 id="添加修改多个数据"><a href="#添加修改多个数据" class="headerlink" title="添加修改多个数据"></a>添加修改多个数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 key2 value2...</span><br></pre></td></tr></table></figure><h5 id="获取多个数据"><a href="#获取多个数据" class="headerlink" title="获取多个数据"></a>获取多个数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key1 key2...</span><br></pre></td></tr></table></figure><h5 id="获取数据的字符个数"><a href="#获取数据的字符个数" class="headerlink" title="获取数据的字符个数"></a>获取数据的字符个数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br><span class="line">//例如</span><br><span class="line">set name1 nosql</span><br><span class="line">strlen name1</span><br><span class="line">//输出为: 5</span><br></pre></td></tr></table></figure><h5 id="追加信息"><a href="#追加信息" class="headerlink" title="追加信息"></a>追加信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br><span class="line">//例如</span><br><span class="line">append name1 name</span><br><span class="line">get name1</span><br><span class="line">/*输出为: nosqlname*/</span><br></pre></td></tr></table></figure><h5 id="多数据操作与单数据操作"><a href="#多数据操作与单数据操作" class="headerlink" title="多数据操作与单数据操作"></a>多数据操作与单数据操作</h5><ul><li>单指令执行 n 条指令需要 n次发送 + n次处理 + n次返回</li><li>多指令执行 n 条指令需要 1次发送 + n次处理 + 1次返回</li><li>数据量较大时，多指令消耗的时间远远少于单指令</li></ul><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="设置数值数据增加-减少指定范围的值"><a href="#设置数值数据增加-减少指定范围的值" class="headerlink" title="设置数值数据增加&#x2F;减少指定范围的值"></a>设置数值数据增加&#x2F;减少指定范围的值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrby key increment</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure><h5 id="对字符串类型进行数值操作"><a href="#对字符串类型进行数值操作" class="headerlink" title="对字符串类型进行数值操作"></a>对字符串类型进行数值操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set mynum &quot;2&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr mynum</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get mynum</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>遇到数值操作，redis会自动将字符串类型转换成数值  </p><h5 id="string类型数值操作的注意事项"><a href="#string类型数值操作的注意事项" class="headerlink" title="string类型数值操作的注意事项"></a>string类型数值操作的注意事项</h5><ul><li>数据操作不成功的反馈与数据正常操作之间的差异<ul><li>表示运行结果是否成功<ul><li>（integer）0-&gt;false 失败</li><li>（integer）1-&gt;true 成功</li></ul></li><li>表示运行结果值<ul><li>（integer）3-&gt;3      3个</li><li>（integer）1-&gt;1      1个</li></ul></li></ul></li><li>数据未获取到<ul><li>（’’nil’’）等同于’’null’’</li></ul></li><li>数据最大存储量<ul><li>512MB</li></ul></li><li>数值计算最大范围（’’java’’中的’’long’’的最大值）<ul><li>9223372036854775807</li></ul></li></ul><hr><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>类似于小型的键值存储，适用于存储结构化数据，如用户信息（ID、姓名、邮箱等），相比 <code>String</code> 类型更节省内存，因为多个字段共享同一个键。可以对字段进行单独操作，避免整体读取修改，适用于存储对象、会话信息等。  </p><h4 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset key field value //添加/修改数据</span><br><span class="line">hget key field //获取数据</span><br><span class="line">hgetall key</span><br><span class="line">hdel key field1 [field2]</span><br></pre></td></tr></table></figure><h5 id="添加-修改多个数据"><a href="#添加-修改多个数据" class="headerlink" title="添加&#x2F;修改多个数据"></a>添加&#x2F;修改多个数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset key field1 value1 field2 value2</span><br></pre></td></tr></table></figure><h5 id="获取多个数据-1"><a href="#获取多个数据-1" class="headerlink" title="获取多个数据"></a>获取多个数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field1 field2...</span><br></pre></td></tr></table></figure><h5 id="获取哈希表中字段的数量"><a href="#获取哈希表中字段的数量" class="headerlink" title="获取哈希表中字段的数量"></a>获取哈希表中字段的数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><h5 id="获取哈希表中是否存在指定的字段"><a href="#获取哈希表中是否存在指定的字段" class="headerlink" title="获取哈希表中是否存在指定的字段"></a>获取哈希表中是否存在指定的字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><h5 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建用户信息</span><br><span class="line">HSET user:1001 name &quot;Alice&quot; email &quot;alice@example.com&quot; age &quot;25&quot;</span><br><span class="line"></span><br><span class="line">// 2. 获取用户的姓名</span><br><span class="line">HGET user:1001 name  # 输出: &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">// 3. 获取整个用户信息</span><br><span class="line">HGETALL user:1001  </span><br><span class="line">// 输出:</span><br><span class="line">// 1) &quot;name&quot;</span><br><span class="line">// 2) &quot;Alice&quot;</span><br><span class="line">// 3) &quot;email&quot;</span><br><span class="line">// 4) &quot;alice@example.com&quot;</span><br><span class="line">// 5) &quot;age&quot;</span><br><span class="line">// 6) &quot;25&quot;</span><br><span class="line"></span><br><span class="line">// 4. 添加/修改多个字段（比如更新用户的电话和地址）</span><br><span class="line">HMSET user:1001 phone &quot;123-456-7890&quot; address &quot;123 Street, City&quot;</span><br><span class="line"></span><br><span class="line">// 5. 获取多个字段的值</span><br><span class="line">HMGET user:1001 name email phone  </span><br><span class="line">// 输出: [&quot;Alice&quot;, &quot;alice@example.com&quot;, &quot;123-456-7890&quot;]</span><br><span class="line"></span><br><span class="line">// 6. 获取哈希表中字段的数量</span><br><span class="line">HLEN user:1001  # 输出: 5</span><br><span class="line"></span><br><span class="line">// 7. 检查字段是否存在</span><br><span class="line">HEXISTS user:1001 email  # 输出: 1 (表示存在)</span><br><span class="line">HEXISTS user:1001 gender  # 输出: 0 (表示不存在)</span><br><span class="line"></span><br><span class="line">// 8. 删除某个字段（如删除用户的电话）</span><br><span class="line">HDEL user:1001 phone</span><br><span class="line"></span><br><span class="line">// 9. 再次获取整个用户信息，确认 phone 字段已删除</span><br><span class="line">HGETALL user:1001  </span><br><span class="line">// 输出:</span><br><span class="line">// 1) &quot;name&quot;</span><br><span class="line">// 2) &quot;Alice&quot;</span><br><span class="line">// 3) &quot;email&quot;</span><br><span class="line">// 4) &quot;alice@example.com&quot;</span><br><span class="line">// 5) &quot;age&quot;</span><br><span class="line">// 6) &quot;25&quot;</span><br><span class="line">// 7) &quot;address&quot;</span><br><span class="line">/* 8) &quot;123 Street, City&quot;*/</span><br></pre></td></tr></table></figure><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="获取哈希表中所有字段名或字段值"><a href="#获取哈希表中所有字段名或字段值" class="headerlink" title="获取哈希表中所有字段名或字段值"></a>获取哈希表中所有字段名或字段值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">hvals key</span><br></pre></td></tr></table></figure><h5 id="设置指定字段的数值数据增加指定范围的值"><a href="#设置指定字段的数值数据增加指定范围的值" class="headerlink" title="设置指定字段的数值数据增加指定范围的值"></a>设置指定字段的数值数据增加指定范围的值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field increment</span><br></pre></td></tr></table></figure><h5 id="hash类型数据操作的注意事项"><a href="#hash类型数据操作的注意事项" class="headerlink" title="hash类型数据操作的注意事项"></a>hash类型数据操作的注意事项</h5><ul><li>1.<code>hash</code>类型下的<code>value</code><strong>只能存储字符串</strong>，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（<code>nil</code>）</li><li>2.每个<code>hash</code>可以存储2^23-1个键值对</li><li>3.<code>hash</code>类型十分贴近对象的数据存储形式，并且可以灵活添加对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，<strong>更不可以将hash作为对象列表使用</strong></li><li>4.<code>hgetall</code>操作可以获取全部属性，如果内部<code>field</code>过多，遍历整体数据效率就会很低，有可能成为数据访问瓶颈</li></ul><hr><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>基于双向链表实现，可以从头部（左侧）或尾部（右侧）快速插入和删除元素，同时支持指定范围的索引读取。适合实现消息队列、时间轴（如微博动态）、任务调度等应用，尤其适用于需要按照插入顺序处理数据的场景。</p><h4 id="基础操作-2"><a href="#基础操作-2" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="添加-修改数据"><a href="#添加-修改数据" class="headerlink" title="添加&#x2F;修改数据"></a>添加&#x2F;修改数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpush key value1 [value2]... //从左边进</span><br><span class="line">rpush key value1 [value2]... /*从右边进*/</span><br></pre></td></tr></table></figure><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>关于<code>lrange</code>:  </p><ul><li>lrange用来获取指定范围的元素  </li><li>-1 代表倒数第一个元素  </li><li>列表元素索引从位置0开始</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start stop</span><br><span class="line">lindex key index</span><br><span class="line">lien key</span><br></pre></td></tr></table></figure><h5 id="获取并移除数据"><a href="#获取并移除数据" class="headerlink" title="获取并移除数据"></a>获取并移除数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br><span class="line">rpop key</span><br></pre></td></tr></table></figure><h5 id="移除指定数据"><a href="#移除指定数据" class="headerlink" title="移除指定数据"></a>移除指定数据</h5><p>关于<code>lrem</code>:  </p><ul><li>参数<code>count</code><ul><li><code>count &gt; 0</code> → 从头（左侧）开始删除<code>count</code>个匹配的<code>value</code></li><li><code>count &lt; 0</code> → 从尾（右侧）开始删除<code>count</code>个匹配的<code>value</code></li><li><code>count = 0</code> → 删除**所有匹配的<code>value</code>**（等价于删除列表中所有该值的元素）</li></ul></li><li>如果<code>key</code>不存在<ul><li>返回 0</li></ul></li><li>常用于<strong>去除列表中的重复元素或清理数据</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br></pre></td></tr></table></figure><h5 id="综合示例-1"><a href="#综合示例-1" class="headerlink" title="综合示例"></a>综合示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 清空列表（确保从头开始）</span><br><span class="line">DEL todo_list</span><br><span class="line"></span><br><span class="line">// 添加待办事项</span><br><span class="line">LPUSH todo_list &quot;写报告&quot; &quot;开会&quot;        // 从左侧添加高优先级任务</span><br><span class="line">RPUSH todo_list &quot;整理文件&quot; &quot;发邮件&quot;     // 从右侧添加普通任务</span><br><span class="line"></span><br><span class="line">// 查看全部待办事项</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">// 输出: [&quot;开会&quot;, &quot;写报告&quot;, &quot;整理文件&quot;, &quot;发邮件&quot;]</span><br><span class="line"></span><br><span class="line">// 查看列表长度</span><br><span class="line">LLEN todo_list</span><br><span class="line">// 输出: 4</span><br><span class="line"></span><br><span class="line">// 查看第 2 个待办事项（索引从 0 开始）</span><br><span class="line">LINDEX todo_list 1</span><br><span class="line">// 输出: &quot;写报告&quot;</span><br><span class="line"></span><br><span class="line">// 获取并处理高优先级任务（从左侧移除）</span><br><span class="line">LPOP todo_list</span><br><span class="line">// 输出: &quot;开会&quot;</span><br><span class="line"></span><br><span class="line">// 获取并处理普通任务（从右侧移除）</span><br><span class="line">RPOP todo_list</span><br><span class="line">// 输出: &quot;发邮件&quot;</span><br><span class="line"></span><br><span class="line">// 查看剩余待办事项</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">// 输出: [&quot;写报告&quot;, &quot;整理文件&quot;]</span><br><span class="line"></span><br><span class="line">// 添加一个重复的待办事项</span><br><span class="line">RPUSH todo_list &quot;整理文件&quot;</span><br><span class="line"></span><br><span class="line">// 查看当前列表（有重复）</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">// 输出: [&quot;写报告&quot;, &quot;整理文件&quot;, &quot;整理文件&quot;]</span><br><span class="line"></span><br><span class="line">// 移除 1 个重复的 &quot;整理文件&quot;（从左侧开始）</span><br><span class="line">LREM todo_list 1 &quot;整理文件&quot;</span><br><span class="line">// 输出: 1（表示移除了 1 个匹配项）</span><br><span class="line"></span><br><span class="line">// 查看清理后的列表</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">// 输出: [&quot;写报告&quot;, &quot;整理文件&quot;]</span><br><span class="line"></span><br><span class="line">// 再添加一个重复项并移除所有 &quot;整理文件&quot;</span><br><span class="line">RPUSH todo_list &quot;整理文件&quot;</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">// 输出: [&quot;写报告&quot;, &quot;整理文件&quot;, &quot;整理文件&quot;]</span><br><span class="line"></span><br><span class="line">LREM todo_list 0 &quot;整理文件&quot;</span><br><span class="line">// 输出: 2（表示移除了 2 个匹配项）</span><br><span class="line"></span><br><span class="line">// 查看最终列表</span><br><span class="line">LRANGE todo_list 0 -1</span><br><span class="line">/* 输出: [&quot;写报告&quot;] */</span><br></pre></td></tr></table></figure><h4 id="扩展操作-2"><a href="#扩展操作-2" class="headerlink" title="扩展操作"></a>扩展操作</h4><h5 id="在规定时间内获取并移除数据"><a href="#在规定时间内获取并移除数据" class="headerlink" title="在规定时间内获取并移除数据"></a>在规定时间内获取并移除数据</h5><p>关于<code>blpop</code>:  </p><ul><li>参数<code>key1 [key2...]</code><ul><li>可以提供多个列表的键名，<code>Redis</code> 会按照顺序依次检查这些列表</li></ul></li><li>参数<code>timeout</code><ul><li>timeout &gt; 0 → 如果列表为空，则最多等待 <code>timeout</code> 秒</li><li>timeout &lt; 0 → 永远<strong>阻塞</strong>，直到有数据可用</li></ul></li><li>适用于<strong>任务队列、生产者-消费者模型</strong>等场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop key1 [key2] timeout</span><br><span class="line">brpop key1 [key2] timeout</span><br></pre></td></tr></table></figure><p>示例  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list1 &quot;a&quot; &quot;b&quot; &quot;c&quot;    // 列表内容：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;a&quot;，返回 [&quot;list1&quot;, &quot;a&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;b&quot;，返回 [&quot;list1&quot;, &quot;b&quot;]</span><br><span class="line">BLPOP list1 10             // 取出 &quot;c&quot;，返回 [&quot;list1&quot;, &quot;c&quot;]</span><br><span class="line">BLPOP list1 10             /* 列表为空，阻塞最多 10 秒，若无新元素，则返回 nil */</span><br></pre></td></tr></table></figure><h5 id="list类型数据操作注意事项"><a href="#list类型数据操作注意事项" class="headerlink" title="list类型数据操作注意事项"></a>list类型数据操作注意事项</h5><ul><li>1.<code>list</code>中保存的数据都是<code>string</code>类型的，数据总容量是有限的，最多2^32-1个元素  </li><li>2.<code>list</code>具有’’索引’’的概念，但是操作数据时通常以’’队列’’的形式进行入队出队操作，或以’’栈’’的形式进行入栈出栈操作  </li><li>3.获取全部数据操作结束索引设置为-1  </li><li>4.<code>list</code>可以对数据进行<code>分页</code>操作，通常第1页的信息来自于<code>list</code>，第2页及更多的信息通过’’数据库’’的形式加载</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/03/17/MySQL/"/>
      <url>/2025/03/17/MySQL/</url>
      
        <content type="html"><![CDATA[<p>MySQL 是一个广受欢迎的开源关系型数据库管理系统（RDBMS），由瑞典公司 MySQL AB 开发，现由 Oracle 维护。它基于结构化查询语言（SQL），适用于管理大规模结构化数据，支持多种操作系统，如 Windows、Linux 和 macOS。MySQL 以其高性能、可靠性和易用性著称，提供丰富的功能，包括事务支持、索引优化、多表连接以及用户权限管理。其核心特点是支持多种存储引擎（如 InnoDB 和 MyISAM），允许用户根据需求灵活选择。此外，MySQL 提供主从复制、分区和集群（如 MySQL Cluster）等功能，适用于高可用性和分布式场景。从 Web 应用后台到企业级数据仓库，MySQL 的应用范围广泛。</p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="http://xuesql.cn/">自学SQL网(教程 视频 练习全套)</a></p><blockquote><p>学完知识就有题做</p></blockquote><hr><p><a href="https://www.zhihu.com/question/30357711"></a></p><p><a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程 | 菜鸟教程</a></p><p><a href="https://blog.csdn.net/weixin_43896929/article/details/120750965">MySQL总结_sq连表-CSDN博客</a></p><p><a href="https://liaoxuefeng.com/books/sql/relational/primary-key/index.html">主键 - SQL教程 - 廖雪峰的官方网站</a></p><blockquote><p>观感最好的教程</p></blockquote><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><blockquote><p>引用自 <a href="https://liaoxuefeng.com/books/sql/relational/index.html">关系模型 - SQL教程 - 廖雪峰的官方网站</a></p></blockquote><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p><table><thead><tr><th>id</th><th>class id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr></tbody></table><p>对于关系表，有个很重要的约束，就是<strong>任意两条记录不能重复</strong>。不能重复不是指两条记录不完全相同，而是指<strong>能够通过某个字段唯一区分出不同的记录</strong>，这个字段被称为<em><strong>主键</strong></em>。</p><p>例如，假设我们把<code>name</code>字段作为主键，那么通过名字<code>小明</code>或<code>小红</code>就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为<strong>插入相同主键的两条记录是不被允许的</strong>。</p><p>对主键的要求，最关键的一点是：记录一旦插入到表中，<strong>主键最好不要再修改，因为主键是用来唯一定位记录的</strong>，修改了主键，会造成一系列的影响。</p><p>由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。</p><p>所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><blockquote><p>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。  </p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>小红</td><td>…</td></tr></tbody></table><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><table><thead><tr><th>id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>一班</td><td>…</td></tr><tr><td>2</td><td>二班</td><td>…</td></tr></tbody></table><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>other columns…</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>…</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>…</td></tr><tr><td>5</td><td>2</td><td>小白</td><td>…</td></tr></tbody></table><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，<strong>可以把数据与另一张表关联起来</strong>，这种列称为<code>外键</code>。</p><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p><p>通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果<code>classes</code>表不存在<code>id=99</code>的记录，<code>students</code>表就无法插入<code>class_id=99</code>的记录。</p><p>由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，<code>class_id</code>仅仅是一个普通的列，只是它起到了外键的作用而已。</p><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th>id</th><th>class_id</th><th>name</th><th>gender</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td><td>M</td><td>90</td></tr><tr><td>2</td><td>1</td><td>小红</td><td>F</td><td>95</td></tr><tr><td>3</td><td>1</td><td>小军</td><td>M</td><td>88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_score (score);</span><br></pre></td></tr></table></figure><p>使用<code>ADD INDEX idx_score (score)</code>就创建了一个名称为<code>idx_score</code>，使用列<code>score</code>的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name_score (name, score);</span><br></pre></td></tr></table></figure><p>索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如<code>gender</code>列，大约一半的记录值是<code>M</code>，另一半是<code>F</code>，因此，对该列创建索引就没有意义。</p><p>可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。</p><p>对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p><p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>通过<code>UNIQUE</code>关键字我们就添加了一个唯一索引。</p><p>也可以只对某一列添加一个唯一约束而不创建唯一索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> uni_name <span class="keyword">UNIQUE</span> (name);</span><br></pre></td></tr></table></figure><p>这种情况下，<code>name</code>列没有索引，但仍然具有唯一性保证。</p><p>无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>通过对数据库表创建索引，可以提高查询速度；</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性；</p><p>数据库索引对于用户和应用程序来说都是透明的。</p><h2 id="SELECT-查询"><a href="#SELECT-查询" class="headerlink" title="SELECT 查询"></a>SELECT 查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> another_condition</span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> …;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> movies </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">year</span><span class="operator">&gt;=</span><span class="number">2010</span> <span class="keyword">AND</span> length_minutes<span class="operator">&lt;</span><span class="number">120</span>;</span><br></pre></td></tr></table></figure><h3 id="筛选数字属性列"><a href="#筛选数字属性列" class="headerlink" title="筛选数字属性列"></a><strong>筛选数字属性列</strong></h3><table><thead><tr><th>关键字</th><th></th><th>例</th></tr></thead><tbody><tr><td>&#x3D;, !&#x3D;, &lt; &lt;&#x3D;, &gt;, ≥</td><td></td><td>col_name !&#x3D; 4</td></tr><tr><td>BETWEEN … AND …</td><td>在两个数之间</td><td>col_name BETWEEN 1.5 AND 10.5</td></tr><tr><td>NOT BETWEEN … AND …</td><td></td><td>col_name NOT BETWEEN 1 AND 10</td></tr><tr><td>IN (…)</td><td>在一个列表</td><td>col_name IN (2, 4, 6)</td></tr><tr><td>NOT IN (…)</td><td></td><td>col_name NOT IN (1, 3, 5)</td></tr></tbody></table><h3 id="筛选字符串属性列"><a href="#筛选字符串属性列" class="headerlink" title="筛选字符串属性列"></a><strong>筛选字符串属性列</strong></h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>&#x3D;</td><td>完全等于</td><td></td></tr><tr><td>!&#x3D; or &lt;&gt;</td><td>不等于</td><td></td></tr><tr><td>LIKE</td><td>没有用通配符等价于 &#x3D;</td><td></td></tr><tr><td>NOT LIKE</td><td>没有用通配符等价于 !&#x3D;</td><td></td></tr><tr><td>%</td><td>通配符</td><td>col_name LIKE “%AT%”</td></tr><tr><td>_(下划线)</td><td></td><td>col_name LIKE “AN_”</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*通配符*/</span></span><br><span class="line">col_name <span class="keyword">LIKE</span> &quot;%AT%&quot;;</span><br><span class="line"><span class="comment">/*&quot;AT&quot;&quot;AT*...&quot;&quot;...*AT&quot;&quot;...*AT*...&quot;均满足条件</span></span><br><span class="line"><span class="comment"> &quot;AT&quot;前后可以有任意字符*/</span></span><br><span class="line">col_name <span class="keyword">LIKE</span> &quot;AN_&quot;;</span><br><span class="line"><span class="comment">/*&quot;AND&quot;可以 &quot;AN&quot;&quot;ANDD&quot;均不行</span></span><br><span class="line"><span class="comment"> 与&#x27;%&#x27;相似 但只代表一个字符*/</span></span><br></pre></td></tr></table></figure><h3 id="过滤-排序"><a href="#过滤-排序" class="headerlink" title="过滤&#x2F;排序"></a>过滤&#x2F;排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用DISTINCT关键字来指定某个或某些属性列唯一返回*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让结果按一个或多个属性列做排序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="comment">/* ASC 升序或 DESC 降序*/</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line"><span class="comment">/*LIMIT来指定只返回多少行结果 </span></span><br><span class="line"><span class="comment"> 用OFFSET来指定从哪一行开始返回*/</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br><span class="line"><span class="comment">/*关于OFFSET 若要输出第N行(及之后)</span></span><br><span class="line"><span class="comment">  则OFFSET的参数须为N-1 */</span></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_132438.png" class="" title="例题1"><hr><h3 id="SELECT复习题"><a href="#SELECT复习题" class="headerlink" title="SELECT复习题"></a>SELECT复习题</h3><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_134213.png" class="" title="例题2"><hr><h3 id="在查询中使用表达式"><a href="#在查询中使用表达式" class="headerlink" title="在查询中使用表达式"></a><strong>在查询中使用表达式</strong></h3><p>实际上AS不仅用在表达式别名上，普通的属性列甚至是表（table）都可以取一个别名，这让SQL更容易理解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--属性列和表取别名的例子</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">AS</span> better_column_name, …</span><br><span class="line"><span class="keyword">FROM</span> a_long_widgets_table_name <span class="keyword">AS</span> mywidgets</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> widget_sales</span><br><span class="line">  <span class="keyword">ON</span> mywidgets.id <span class="operator">=</span> widget_sales.widget_id;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--包含表达式的例子</span></span><br><span class="line"><span class="keyword">SELECT</span>  particle_speed <span class="operator">/</span> <span class="number">2.0</span> <span class="keyword">AS</span> half_particle_speed <span class="comment">--对结果做了一个除2</span></span><br><span class="line"><span class="keyword">FROM</span> physics_data</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">ABS</span>(particle_position) <span class="operator">*</span> <span class="number">10.0</span> <span class="operator">&gt;</span><span class="number">500</span></span><br><span class="line">            <span class="comment">--（条件要求这个属性绝对值乘以10大于500）;</span></span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-13_164705.png" class="" title="例题3"><hr><h3 id="在查询中进行统计"><a href="#在查询中进行统计" class="headerlink" title="在查询中进行统计"></a><strong>在查询中进行统计</strong></h3><img src="/2025/03/17/MySQL/v2-89b10c80ff69acdb02494042f55c59d2_1440w.webp" class="" title="样图1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> AGG_FUNC(column_or_expression) <span class="keyword">AS</span> aggregate_description, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> constraint_expression;</span><br></pre></td></tr></table></figure><p>常用统计函数:</p><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>COUNT(*) COUNT(column)</td><td>计数！COUNT(*) 统计数据行数，COUNT(column) 统计column非NULL的行数</td></tr><tr><td>MIN(column)</td><td>找column最小的一行</td></tr><tr><td>MAX(column)</td><td>找column最大的一行</td></tr><tr><td>AVG(column)</td><td>对column所有行取平均值</td></tr><tr><td>SUM(column)</td><td>对column所有行求和</td></tr></tbody></table><hr><h3 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h3><p><code>GROUP BY</code> 数据分组语法可以按某个<code>col_name</code>对数据进行分组，如：<code>GROUP BY Year</code>指对数据按年份分组， 相同年份的分到一个组里。如果把统计函数和<code>GROUP BY</code>结合，那统计结果就是对分组内的数据统计了<br><code>GROUP BY</code> 分组结果的数据条数，就是分组数量，比如：<code>GROUP BY Year</code>，全部数据里有几年，就返回几条数据， 不管是否应用了统计函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用分组的方式统计</span></span><br><span class="line"><span class="keyword">SELECT</span> AGG_FUNC(column_or_expression) <span class="keyword">AS</span> aggregate_description, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> constraint_expression</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span>;</span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-13_170736.png" class="" title="例题4"><p>在 <strong><code>GROUP BY</code></strong> 分组语法中，我们知道数据库是先对数据做 <strong><code>WHERE</code></strong> ，然后对结果做分组，如果我们要对分组完的数据再筛选出几条如何办？<br>一个不常用的语法 <strong><code>HAVING</code></strong> 语法将用来解决这个问题，他可以对分组之后的数据再做<code>SELECT</code>筛选</p><p><strong><code>HAVING</code></strong> 和 <strong><code>WHERE</code></strong> 语法一样，只不过作用的结果集不一样. 在我们例子数据表数据量小的情况下可能感觉 <strong><code>HAVING</code></strong> 没有什么用，但当你的数据量成千上万属性又很多时也许能帮上大忙</p><hr><h3 id="JOIN-连接"><a href="#JOIN-连接" class="headerlink" title="JOIN 连接"></a>JOIN 连接</h3><h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><p>数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的重复数据降到最少(这有助于数据的一致性维护)同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长(ie. 比如汽车引擎的增长和汽车的增长是完全独立的)  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_table_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable <span class="comment">--主表</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> another_table <span class="comment">--要连接的表</span></span><br><span class="line">    <span class="keyword">ON</span> mytable.id <span class="operator">=</span> another_table.id </span><br><span class="line">    <span class="comment">--想象一下刚才讲的主键连接，两个相同的连成1条</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>, … <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br></pre></td></tr></table></figure><p>本例中<code>ON</code>条件描述的关联关系:</p><h4 id="INNER-JOIN-内-连接"><a href="#INNER-JOIN-内-连接" class="headerlink" title="INNER JOIN (内)连接"></a><strong><code>INNER JOIN</code></strong> (内)连接</h4><p> 先将两个表数据连接到一起，两个表中如果通过ID互相找不到的数据将会舍弃。此时，你可以将连表后的数据看作两个表的合并，SQL中的其他语句会在这个合并基础上 继续执行(想一下和之前的单表操作就一样了)<br>还有一个理解 <strong><code>INNER JOIN</code></strong> 的方式，就是把 <strong><code>INNER JOIN</code></strong> 想成两个集合的交集。</p><p><img src="C:/Users/Kawauso/Documents/Blogs/source/_posts/MySQL/Screenshot_2025-03-11_142245.png" alt="例题5"></p><h4 id="OUTER-JOIN外连接"><a href="#OUTER-JOIN外连接" class="headerlink" title="OUTER JOIN外连接"></a><code>OUTER JOIN</code>外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用LEFT/RIGHT/FULL JOINs 做多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">INNER</span><span class="operator">/</span><span class="keyword">LEFT</span><span class="operator">/</span><span class="keyword">RIGHT</span><span class="operator">/</span><span class="keyword">FULL</span> <span class="keyword">JOIN</span> another_table</span><br><span class="line">    <span class="keyword">ON</span> mytable.id <span class="operator">=</span> another_table.matching_id</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>(s)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>, … <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT num_limit <span class="keyword">OFFSET</span> num_offset;</span><br></pre></td></tr></table></figure><p>在表A 连接 B， <strong><code>LEFT JOIN</code></strong> 保留A的所有行，不管有没有能匹配上B，反过来 <strong><code>RIGHT JOIN</code><strong>则保留所有B里的行。最后</strong><code>FULL JOIN</code></strong> 不管有没有匹配上，同时保留A和B里的所有行</p><p>将两个表数据1-1连接，保留A或B的原有行，如果某一行在另一个表不存在，会用 <code>NULL</code>来填充结果数据。</p><p><img src="C:/Users/Kawauso/Documents/Blogs/source/_posts/MySQL/Screenshot_2025-03-11_151348.png" alt="例题6"></p><hr><h3 id="查询执行顺序"><a href="#查询执行顺序" class="headerlink" title="查询执行顺序"></a>查询执行顺序</h3><img src="/2025/03/17/MySQL/v2-d414289449f1dcaaa8c81e13de989b57_1440w.webp" class="" title="样图2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--这才是完整的SELECT查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">column</span>, AGG_FUNC(column_or_expression), …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">    <span class="keyword">JOIN</span> another_table</span><br><span class="line">      <span class="keyword">ON</span> mytable.column <span class="operator">=</span> another_table.column</span><br><span class="line">    <span class="keyword">WHERE</span> constraint_expression</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">    <span class="keyword">HAVING</span> constraint_expression</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">    LIMIT count <span class="keyword">OFFSET</span> COUNT;</span><br></pre></td></tr></table></figure><h4 id="1-FROM-和-JOIN"><a href="#1-FROM-和-JOIN" class="headerlink" title="1. FROM 和 JOIN"></a>1. <code>FROM</code> 和 <code>JOIN</code></h4><p><strong><code>FROM</code></strong> 或  <strong><code>JOIN</code></strong> 会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于 下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表）</p><h4 id="2-WHERE"><a href="#2-WHERE" class="headerlink" title="2. WHERE"></a><strong>2. <code>WHERE</code></strong></h4><p>我们确定了数据来源 <strong><code>WHERE</code></strong> 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性 只能来自 <strong><code>FROM</code></strong> 圈定的表. <code>AS</code>别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式</p><h4 id="3-GROUP-BY"><a href="#3-GROUP-BY" class="headerlink" title="3. GROUP BY"></a><strong>3. <code>GROUP BY</code></strong></h4><p>如果你用了 <strong><code>GROUP BY</code></strong> 分组，那 <strong><code>GROUP BY</code></strong> 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.</p><h4 id="4-HAVING"><a href="#4-HAVING" class="headerlink" title="4. HAVING"></a><strong>4. <code>HAVING</code></strong></h4><p>如果你用了 <strong><code>GROUP BY</code></strong> 分组, <strong><code>HAVING</code></strong> 会在分组完成后对结果集再次筛选。<code>AS</code>别名也不能在这个阶段使用.</p><h4 id="5-SELECT"><a href="#5-SELECT" class="headerlink" title="5. SELECT"></a><strong>5. <code>SELECT</code></strong></h4><p>确定结果之后， <strong><code>SELECT</code></strong> 用来对结果col简单筛选或计算，决定输出什么数据.</p><h4 id="6-DISTINCT"><a href="#6-DISTINCT" class="headerlink" title="6. DISTINCT"></a><strong>6. <code>DISTINCT</code></strong></h4><p>如果数据行有重复 <strong><code>DISTINCT</code></strong> 将负责排重.</p><h4 id="7-ORDER-BY"><a href="#7-ORDER-BY" class="headerlink" title="7. ORDER BY"></a><strong>7. <code>ORDER BY</code></strong></h4><p>在结果集确定的情况下， <strong><code>ORDER BY</code></strong> 对结果做排序。因为 <strong><code>SELECT</code></strong> 中的表达式已经执行完了。此时可以用<code>AS</code>别名.</p><h4 id="8-LIMIT-OFFSET"><a href="#8-LIMIT-OFFSET" class="headerlink" title="8. LIMIT &#x2F; OFFSET"></a><strong>8. <code>LIMIT</code> &#x2F; <code>OFFSET</code></strong></h4><p>最后 <strong><code>LIMIT</code></strong> 和 <strong><code>OFFSET</code></strong> 从排序的结果中截取部分数据.</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题 都抛给程序逻辑.</p><hr><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>如果某个字段你没有填写到数据库，很可能就会出现 <strong><code>NULL</code></strong>  。所有一个常见的方式就是为字段设置 <strong><code>默认值</code></strong> ,比如 数字的默认值设置为0，字符串设置为  <code>&quot;&quot;</code> 字符串. 但是在一些 <strong><code>NULL</code></strong> 表示它本来含义的场景，需要注意是否设置默认值还是保持 <strong><code>NULL</code></strong> 。 (比如, 当你计算一些行的平均值的时候，如果是0会参与计算导致平均值差错，是  <strong><code>NULL</code></strong> 则不会参与计算).</p><p>还有一些情况很难避免 <strong><code>NULL</code></strong> 的出现, 比如之前说的 outer-joining 多表连接，A和B有数据差异时，必须用 <strong><code>NULL</code></strong> 来填充。这种情况，可以用 <strong><code>IS NULL</code></strong> 和 <strong><code>IS NOT NULL</code></strong> 来选在某个字段是否等于 <strong><code>NULL</code></strong>.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">IS</span><span class="operator">/</span><span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> another_condition</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> …;</span><br></pre></td></tr></table></figure><img src="/2025/03/17/MySQL/Screenshot_2025-03-11_203039.png" class="" title="例题7"><hr><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><blockquote><p>部分引用自 <a href="https://liaoxuefeng.com/books/sql/manipulation/index.html">修改数据 - SQL教程 - 廖雪峰的官方网站</a></p></blockquote><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。其中，对于查询，我们已经详细讲述了<code>SELECT</code>语句的详细用法。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><p>我们将分别讨论这三种修改数据的语句的使用方法。</p><h4 id="INSERT-插入"><a href="#INSERT-插入" class="headerlink" title="INSERT 插入"></a>INSERT 插入</h4><p>引用于 <a href="https://www.runoob.com/mysql/mysql-insert-query.html">MySQL 插入数据 | 菜鸟教程</a></p><p>例如，我们向<code>user</code>表插入一条新记录，先列举出需要插入的字段名称，然后在<code>VALUES</code>子句中依次写出对应字段的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> users (username, email, birthdate, is_active)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test@runoob.com&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>如果要插入所有列(即插入行)的数据，可以省略列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">NULL</span>,<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test@runoob.com&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值，每组值用逗号<code>,</code>分隔：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (username, email, birthdate, is_active)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;test1@runoob.com&#x27;</span>, <span class="string">&#x27;1985-07-10&#x27;</span>, <span class="literal">true</span>),</span><br><span class="line">    (<span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;test2@runoob.com&#x27;</span>, <span class="string">&#x27;1988-11-25&#x27;</span>, <span class="literal">false</span>),</span><br><span class="line">    (<span class="string">&#x27;test3&#x27;</span>, <span class="string">&#x27;test3@runoob.com&#x27;</span>, <span class="string">&#x27;1993-05-03&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h3><p><a href="https://www.runoob.com/mysql/mysql-update-query.html">MySQL UPDATE 更新 | 菜鸟教程</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>table_name</code> 是你要更新数据的表的名称。</li><li><code>column1</code>, <code>column2</code>, … 是你要更新的列的名称。</li><li><code>value1</code>, <code>value2</code>, … 是新的值，用于替换旧的值。</li><li><code>WHERE condition</code> 是一个可选的子句，用于指定更新的行。如果省略 <code>WHERE</code> 子句，将更新表中的所有行。</li></ul><p><strong>更多说明：</strong></p><ul><li>你可以同时更新一个或多个字段。</li><li>你可以在 <code>WHERE</code> 子句中指定任何条件。</li><li>你可以在一个单独表中同时更新数据。</li></ul><p>当你需要更新数据表中指定行的数据时 <code>WHERE</code> 子句是非常有用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--更新单个列的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">60000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">101</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--更新多个列的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> orders</span><br><span class="line"><span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;Shipped&#x27;</span>, ship_date <span class="operator">=</span> <span class="string">&#x27;2023-03-01&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="number">1001</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用表达式更新值</span></span><br><span class="line"><span class="keyword">UPDATE</span> products</span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> price <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--更新使用子查询的值</span></span><br><span class="line"><span class="keyword">UPDATE</span> customers</span><br><span class="line"><span class="keyword">SET</span> total_purchases <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount)</span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">WHERE</span> orders.customer_id <span class="operator">=</span> customers.customer_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> customer_type <span class="operator">=</span> <span class="string">&#x27;Premium&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在使用MySQL这类真正的关系数据库时，<code>UPDATE</code>语句会返回更新的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，更新<code>id=1</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>1</code>，可以从打印的结果<code>Rows matched: 1 Changed: 1</code>看到。</p><p>当更新<code>id=999</code>的记录时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 0  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>MySQL会返回<code>0</code>，可以从打印的结果<code>Rows matched: 0 Changed: 0</code>看到。</p><hr><h3 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE 删除"></a>DELETE 删除</h3><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p>例如，我们想删除<code>students</code>表中<code>id=1</code>的记录，就需要这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=1的记录:</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>注意到<code>DELETE</code>语句的<code>WHERE</code>条件也是用来筛选需要删除的行，因此和<code>UPDATE</code>类似，<code>DELETE</code>语句也可以一次删除多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录:</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>如果<code>WHERE</code>条件没有匹配到任何记录，<code>DELETE</code>语句不会报错，也不会有任何记录被删除。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=999的记录:</span><br><span class="line">DELETE FROM students WHERE id=999;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p>最后，要特别小心的是，和<code>UPDATE</code>类似，不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students;</span><br></pre></td></tr></table></figure><p>这时，整个表的所有记录都会被删除。所以，在执行<code>DELETE</code>语句时也要非常小心，最好先用<code>SELECT</code>语句来测试<code>WHERE</code>条件是否筛选出了期望的记录集，然后再用<code>DELETE</code>删除。 </p><p>在使用MySQL这类真正的关系数据库时，<code>DELETE</code>语句也会返回删除的行数以及<code>WHERE</code>条件匹配的行数。</p><p>例如，分别执行删除<code>id=1</code>和<code>id=999</code>的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM students WHERE id=1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM students WHERE id=999;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><hr><h2 id="CREATE-创建"><a href="#CREATE-创建" class="headerlink" title="CREATE 创建"></a>CREATE 创建</h2><p><a href="https://www.runoob.com/mysql/mysql-create-tables.html">MySQL 创建数据表 | 菜鸟教程</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用户表实例</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    birthdate <span class="type">DATE</span>,</span><br><span class="line">    is_active <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实例解析：</p><ul><li><code>id</code>: 用户 id，整数类型，自增长，作为主键。</li><li><code>username</code>: 用户名，变长字符串，不允许为空。</li><li><code>email</code>: 用户邮箱，变长字符串，不允许为空。</li><li><code>birthdate</code>: 用户的生日，日期类型。</li><li><code>is_active</code>: 用户是否已经激活，布尔类型，默认值为 true。</li></ul><p>以上只是一个简单的实例，用到了一些常见的数据类型包括<code>INT</code>, <code>VARCHAR</code>, <code>DATE</code>, <code>BOOLEAN</code>，可以根据实际需要选择不同的数据类型。</p><p><code>AUTO_INCREMENT</code> 关键字用于创建一个自增长的列，<code>PRIMARY KEY</code> 用于定义主键。</p><p>如果希望在创建表时指定数据引擎，字符集和排序规则等，可以使用 <strong><code>CHARACTER SET</code></strong> 和 <strong><code>COLLATE</code></strong> 子句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> mytable (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/17/hello-world/"/>
      <url>/2025/03/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
